{"./":{"url":"./","title":"前言","keywords":"","body":"前言 修订说明：本书内容基于「小霸王Lite」两轮自平衡小车 V3.0 （2019 年 1 月 1 日起出货） 进行重新修订，当前版本号为 1.0.9（更新于2020.08.23）。 如果你从没做过两轮自平衡小车， 打算自己做一辆， 又或者想学习一下， 这本书就是为你准备的。 「小霸王Lite」是一款小巧、灵活、开源、低成本的两轮自平衡小车，它可以帮助你很轻松地完成智能自平衡小车项目制作、课程设计、毕业设计。你可以通过 C 语言对它进行编程，实现完全控制「小霸王Lite」，包括控制芯片的所有 GPIO 引脚。 本书围绕「小霸王Lite」两轮自平衡小车编写，以尽可能通俗易懂的语言和例子，从理论解释到编写代码，从原理图设计到洞洞板焊接，详尽地将「如何制作一辆两轮自平衡小车」完整地呈现出来。 配套硬件 淘宝链接：「小霸王Lite」两轮自平衡小车 算法和代码是关健。直接使用配套硬件，能腾出更多时间来研究算法和代码。 交流社区 如需交流技术问题，请前往社区发帖：https://bbs.miaowlabs.com/ 仅开放邀请注册，-->点击注册。论坛社区能存储数据，方便查找问题，是一种很好的信息交流方式。 分发协议 在分发本书时，请完整保留本书原链接： https://c.miaowlabs.com 本书支持在线阅读，并提供 PDF 离线版本。推荐在线阅读，在线阅读的视频观看效果更佳。 联系我们 邮箱：121349840@qq.com 因作者能力有限，在写作过程中难免会有错漏。如发现错误，请指正。 版权所有 本书版权归喵呜实验室MiaowLabs所有。未经授权，禁止转载。禁止一切形式的抄袭和改编。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Z01.html":{"url":"Z01.html","title":"关于本书","keywords":"","body":"关于本书 本书主要面向有 MCU 开发经验，希望从零开始学习两轮自平衡小车开发的嵌入式软件工程师及在校学生。 目前国内关于两轮自平衡小车开发的教材大都比较老旧，要么是基于多年前的飞思卡尔 MCU，要么是零散博客写的心得体会不成系统，对于主流的技术如 STM32F1、MPU-6050 等鲜有介绍。本书希望打破这种局面，配套的硬件平台采用 STM32F103（Cortex-M3 架构的 CPU）， 使用 STM32CubeMX + Keil-MDK 进行代码配置， 循序渐进且涉及的知识全面，紧跟技术潮流，为学习者建立起两轮自平衡小车开发的全貌。 本书将分为以下几个部分进行讲解。 第一部分主要是初步熟悉配套的开发套件。 第二部分通过分析平衡原理，进行数学建模并进行 Simulink 仿真，带领读者“知其所以然”。 第三部分为读者讲解电路硬件框架，为编写代码做好准备。 第四部分通过循序渐进的方式带领读者编写代码，从零开始直至让小车稳定平衡。 在第四部分我们特意使用手把手教学方式，给每个实验章节都配套对应的例程，就是希望让大家尽快接触开发套件，提高学习的热情，而不是让开发套件躺着吃灰。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A32.html":{"url":"A32.html","title":"推荐学习路线","keywords":"","body":"学习路线推荐 本小节给新手推荐一些学习方法和学习方向。 你可能感到迷茫： 想要制作一辆两轮自平衡小车，却不知道该从哪里入手... 这是新手在学习新知识时最先遇到的困难。如果有人指点一下，给出学习顺序，会使新手少走很多弯路。就好比没做过菜的你突然想煎一个荷包蛋，却在纠结着下锅的顺序——是先放油还是先放鸡蛋？如果有人在旁边告诉你，应该先放油，然后再敲蛋下锅，那这次煎蛋的成功率将大大提高。 如果按照重要程度划分，我认为新手关注内容的顺序应该是 代码 > 电路 > 机械 为什么这么说？理由很简单但充分。 嵌入式系统都可以看作是由硬件和软件两大部分组成的，两轮自平衡小车也不例外。 两轮自平衡小车 = 硬件 + 软件 其中，硬件 = 机械 + 电路，软件即指代码。每一部分都重要，硬件是肉身，软件是灵魂，两者相互依赖。没有灵魂的肉身只是行尸走肉，失去肉身的灵魂无法表现自身价值。 由此替换， 两轮自平衡小车 = 机械 + 电路 + 代码 机械 机械其实很讲究，消费级产品通常会用电脑建模，打样出来验证，通过再量产。但是，在这里，两轮自平衡小车只是一个极客型产品，裸露出电路板才是真极客。机械机构不需要外壳，因此变得简单起来，能拼装起来即可。 电路 电路可以分为两大部分， 电路= 核心电路+ 扩展电路。 其中，核心电路 = 控制器 + 传感器 + 稳压电路 + 驱动电路。核心电路是制作两轮自平衡小车的必备电路。扩展电路则视不同需求添加，比如要实现超声波避障功能就添加超声波模块，要实现红外循迹功能就添加红外循迹模块。 电路可以是全部集成化设计到一块电路板上，也可以是购买或制作不同功能的模块再组合到一起。 在电路学习方面，要了解小车电路的组成，各个电路模块的作用。尤其需要深入了解核心电路的功能和作用。 举个例子，控制器电路部分的学习应该对照 Datasheet（规格书）了解每个引脚的在系统中的作用，比如 PA6 引脚复位后默认功能是 GPIO，可选复用功能有 SPI1_MISO/ADC12_IN6/TIM3_CH1 三种功能，但在小车的电路上只是作为 TIM3_CH1 功能使用，即 定时器 3 的 1 通道 PWM 输出。 再举个例子，传感器 MPU-6050 模块一共有 8 个引脚，但是在系统中只用到了 4 个引脚（VCC|GND|CLK|SDA）。VCC 和 GND 就不用多说了，供电给芯片工作，可不能想马儿跑又不让马儿吃草。还有另外两根线，这是因为 MPU-6050 芯片是一款通过 I2C 协议发送数据的数字传感器，I2C 协议则是两线式串行总线，CLK 和 SDA 是 I2C 总线的两根线，只需要连接这两根线就可以查询到 MPU-6050 芯片的数据。 搞清楚核心电路每个引脚的作用对理解代码有很大帮助。 代码 代码很关键。代码即程序。伟大的图灵奖获得者 Nicklaus Wirth 曾提出一条著名的公式： 程序 = 算法 + 数据结构。 这句话也常常出现在我们的编程学习课本上。 在同样的硬件上，优秀的软件（算法）通常表现更优异。比如，在参数都整定到位的情况下，模糊 PID 算法会比 标准 PID 算法好，前者鲁棒性更好，抗干扰能力更强，响应更迅速。因此，要花费更多的时间和精力在代码、算法上。 两轮自平衡小车是一种典型的欠驱动系统，核心的算法涉及到平衡控制和运动控制，难度偏中等。新手在学习算法过程中会不断接触到新概念，这也需要投入更多的时间精力才能获得更好的学习效果。算法没有最优解，只有更优解。经过学习一段时间，如果新手研究透彻原来的算法，可以尝试修改优化原算法，以得到更好的控制效果。 在写这本书的时候，我就有考虑到学习顺序和学习重点，并且把重点放在代码的编写部分，按照“代码 > 电路 > 机械”的理念进行编排，只要按着顺序往下阅读，就能循序渐进地制作出一辆两轮自平衡小车。 有对知识的渴望是很好的学习动力，但是我们应该了解自身的条件，一步一个脚印开始，不可以一下子就想象自己可以很快蜕变。对自己的成长给点耐心，让自己在学习中慢慢累积，最终会厚积薄发。 祝学习愉快。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A09.html":{"url":"A09.html","title":"必看开箱组装","keywords":"","body":"组装测试 本小节教你如何组装小车，并对小车的功能进行测试。 开箱组装视频教程 （点击文字可转跳到视频网站） 功能测试视频教程 （点击文字可转跳到视频网站） 装拆电池小技巧 （点击文字可转跳到视频网站） 电池充电小技巧 （点击文字可转跳到视频网站） 文字版教程 注意：动态图只能在 PC 端正常显示，如需观看动态图，请使用浏览器查看本章节。 萌新们在拿到套件时，请先按捺住内心的小激动，因为我们是散件发货，要先组装小车。让我们动作温柔地打开包装盒，然后对照下方的发货清单表格，检查一遍有没有缺漏配件。你会看到部分电子模块已经安装到底板上了，因为在生产时，工厂已经把一部分容易难安装的电子模块预装到底板上了。在实际组装当中，我们可以省略安装这些模块的过程。 温馨提示：为了充分利用时间，在开始组装前，我们先用充电器对电池进行充电。充电中指示灯为红色，充满时指示灯为绿色。电池和充电器的「+ -」极性要对应。充满电大约需要 5 个小时。电池额定电压为 7.4v，充满电压为 8.4v。电池电压小于额定电压 7.2v 时，已是低电量状态，处于低电量状态的小车是很容易翻车的，请记得及时充电。 发货清单如下：（打“√”代表“有”） 序号 名称 数量 标准版 增强版 1 STM32 核心板 1 √ √ 2 MPU-6050 模块 1 √ √ 3 TB6612FNG 模块 1 √ √ 4 5V/3.3V 稳压模块 1 √ √ 5 蓝牙模块 1 √ √ 6 专用底板 1 √ √ 7 亚克力板 1 √ √ 8 直流减速电机 2 √ √ 9 优质内胆轮胎 2 √ √ 10 动力锂电池 2 √ √ 11 电机固定部件包（含螺丝） 1 √ √ 12 塑料支撑柱包（含螺丝螺母） 1 √ √ 13 电机连接线 2 √ √ 13 Micro-USB 数据线 1 √ √ 14 螺丝刀 1 √ √ 15 超声波模块 1 无 √ 16 0.96OLED 显示模块 1 无 √ 17 红外巡线模块（含支撑柱等） 1 无 √ 组装过程 部分电子模块出厂时已预装在底板，萌新请自行跳过相关的组装步骤。 电机的编码器为易损部件，在拿电机时要小心谨慎，不要随意掰扯编码器的传感器。 1、安装电机固定部件。固定部件的四个孔位都是攻丝孔，跟螺母类似，所以拧紧固定部件只用螺丝就行了。将固定部件放在相关位置（电路板上有文字提示），从电路板另一面（有电池盒的那一面）往上拧紧螺丝，就能固定住部件。 Image 2.1.1 - 安装电机固定部件 2、安装电机。注意电机输出轴是朝外安装，不然等下安装轮胎会发现电机装反了哦。 Image 2.1.2 - 安装电机 3、安装 TB6612FNG 驱动模块。模块和底板上的引脚丝印要对应安装，装反会损坏模块哦。 Image 2.1.3 - 安装 TB6612FNG 驱动模块 4、安装 MPU-6050 陀螺仪/加速度传感器模块。插好模块，并用螺丝固定有隔离柱的一端。 Image 2.1.4 - 安装 MPU-6050 模块 5、安装 9Vto5V/3.3V 电源降压模块。模块和底板上的引脚丝印要对应安装，装反会损坏模块哦。 Image 2.1.5 - 安装 9Vto5v/3.3v 电源降压模块 6、安装 STM32 控制板。模块和底板的引脚丝印要对应安装。 Image 2.1.6 - 安装 STM32 控制板 7、安装电机连接线 Image 2.1.7 - 安装电机连接线 8、安装蓝牙模块。模块和底板的引脚丝印要对应安装。 Image 2.1.8 - 安装蓝牙模块 9、安装四根塑料支撑柱 Image 2.1.9 - 安装四根塑料支撑柱 10、撕掉亚克力保护膜 Image 2.1.10 - 撕掉亚克力保护膜 10、安装透明亚克力 Image 2.1.11 - 安装透明亚克力 11、安装轮胎 。轮胎孔位为D型孔，对准才能安装进去，不能蛮力安装哦。 Image 2.1.12 - 安装轮胎 12、安装电池。记得起码要先充电三个小时。电池容易安装错，一定先看清楚正负极性，电池的正负要和电路板上的「正+ 负-」标注文字对应起来。（是让电池对应底板、底板、底板上标注的正负，不是电池盒的）。 Image 2.1.13 - 安装电池 13、安装完毕。先不要急着上电，测试过程请接着继续往下看。 Image 2.1.14 - 安装完毕 标准版（官方标配）套件到这里已安装完毕。如果是增强版套件，还需要继续安装红外巡线模块、超声波模块、OLED 模块。 13、安装超声波模块。底板背面上印刷有丝印“超声波模块接口”，找到超声波模块接口，把超声波模块插好。 14、安装 OLED 模块。OLED 模块的孔位在靠近稳压模块，底板背面上印刷有丝印“0.96 OLED 模块接口”，找到 OLED 模块接口，把 OLED 模块插好。 15、安装红外巡线模块。红外模块的安装孔位在超声波模块的两端，先用螺母将隔离柱拧紧在模块上，然后再用螺丝将模块和隔离柱固定在底板上。红外模块容易装错，请对照示意图安装。 Image 2.1.15 - 组装完成的增强版小车 安装到这里，红外巡线模块、超声波模块、OLED 模块也都已经安装好了。萌新们对照示意图，看一下自己有没有把红外模块装反着安装了。有的话，纠正过来。 功能测试 1、在开机之前，我们最好确认一遍电池没有装反，再上电开机。 2、平衡测试。把小车轻放在地面，扶正小车，开机，此时小车会保持平衡。 3、提起识别。把小车拿起来，小车会识别这个动作，并且关停电机转动。 4、着陆识别。把小车放回地面，扶正车体保持 3 秒，小车会识别动作，然后恢复平衡。 注意：扶正 90° 角度不一定能识别着陆，可以尝试在 90° 附近的角度保持 3 秒。因为安装偏差，每台小车的重心不一定完全在车体的竖直方向。萌新们自行感受下这个动作哈。 5、在匹配蓝牙时，将「小霸王Lite」两轮自平衡小车轻放至地面，扶正小车，开机，使其处于正常平衡状态。关机状态时，手机将无法匹配和连接小车蓝牙。拿出安卓手机，搜索设备（MiaowLabs-XXXX 或 BT-04）、匹配蓝牙。蓝牙匹配密钥为：1234。资料包的 APP 文件夹里有两款 APP 安装包，一款为「喵呜手机端」，另一款为「喵呜手机端（简易版）」（曾用名「平衡小车通用控制」）。用户按需安装使用。 有些手机在第一次搜索时搜索不到蓝牙，请在手机设置中对关闭蓝牙再开启，重新搜索。一次搜索不到那就搜索三次。试了多次还不行就请换一台手机吧。蓝牙配对成功之后直接打开 APP 连接即可。别拿苹果手机 iphone 来搜索蓝牙，我们的 APP 暂时只支持安卓手机。 切换工作模式 切换不同的工作模式，需要使用 APP 进行切换，或修改代码进行切换。光盘中两款 APP 都有工作模式切换功能。修改代码更换可以切换开机工作模式，默认的开机工作模式为蓝牙遥控模式，在未接收到遥控指令时，会在原地保持平衡等待指令。 APP 中有四种工作模式可供选择： 遥控模式（默认模式） 超声波避障模式 超声波跟随模式 红外循迹模式 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A33.html":{"url":"A33.html","title":"参数特点一览","keywords":"","body":"参数特点一览 本小节介绍「小霸王Lite」两轮自平衡小车的详细参数和特点。 「小霸王Lite」是一款小巧、灵活、开源、低成本的两轮自平衡小车，它可以帮助你很轻松地完成智能自平衡小车项目制作、课程设计、毕业设计。你可以通过 C 语言对它进行编程，实现完全控制「小霸王Lite」，包括控制芯片的所有 IO 引脚。控制芯片的 IO 引脚全排针引出，你可以非常轻易地使用杜邦线连接引脚与扩展模块，实现你的创意。 详细参数： Image 2.2.1 - 详细参数 「小霸王Lite」两轮自平衡小车的特点： 主控 STM32F103C8T6 ARM Cortex-M3 32 位处理器，72 MHz 主频（1.25 DMIPS/MHz 运算能力），64K Flash，20K SRAM，性能优秀，扩展空间大； 主控 STM32F103C8T6 所有 IO 引脚在底板上均用标准 2.54mm 排针引出，这意味着允许你使用杜邦线连接各种模块，扩展起来非常方便； 主控 STM32F103C8T6 使用经典 LQFP48 封装，共 48 个引脚，除去电源地晶振等 16 个非功能引脚，剩余 32 个功能引脚。 实现平衡功能必须使用的主控引脚共 12 个，功能划分如下： PB8/PB9： 连接 MPU-6050 PB0/PB1/PA3/PA4：连接 TB6612FNG，GPIO 功能，控制电机方向 PA6/PA7：连接 TB6612FNG，PWM 功能，控制电机转速 PB6/PB7/PA0/PA1：连接编码器，正交解码功能，获取电机转速 上述 12 个引脚是你不能再动（使用）的引脚，因为已经是平衡功能必需使用。你再使用，会破坏掉最基本的平衡功能。 剩余作为扩展功能使用的主控引脚共 20 个，功能划分如下： 在核心板上，PA13/PA14 默认作为 SWD 功能引脚，PB12 默认连接 LED，PA11 默认已连接 Buttom（按键），PA9/PA10 默认已连接 USB-TTL 芯片。但是，当 IO 引脚需求紧缺时，一样可以共用这些引脚，比如超声波模块和按键共用 PA11 引脚。 PB10/PB11：连接 SPP Bluetooth V3.0（蓝牙）模块 PB13/PB14/PB15/PC13：连接 SPI 0.96 寸 OLED 显示模块 PA11/PA2：连接超声波模块 PA8/PA15/PB3/PB5：连接红外循迹模块 PA12/PA15/PB3/PB4/PB10/PB11：连接 ESP8266 Wifi 模块 PA8/PA12/PA15/PB3/PB4/PB5：连接 nRF24L01 2.4G 模块 上述的 18 个 IO 引脚是你可以按照你的想法进行使用的引脚。我把这 18 个 IO 引脚划分给上述的模块，并在底板上预留了这些接口。但是，你要明白预留接口不等于只能接这些模块。你可以自己重新规划功能使用。上述部分扩展模块共用同一 IO 引脚，若冲突，不能同时使用，比如 SPP Bluetooth V3.0（蓝牙）模块和 ESP8266 模块不能同时使用。我们在底板上预留了上面模块的接口，可以直接插上去使用。若需要使用 IO 引脚连接其他没在底板预留接口的模块，比如舵机、摄像头等，可以使用杜邦线与其连接。 板载 CP2102 USB-TTL 芯片和 Micro-USB 插口，使用 Micro-USB 数据线就能烧录程序； 板载 3 种通信模块接口（ESP8266 与 Bluetooth 共用部分 IO 引脚，两者不能同时使用）： nRF24L01 2.4G 无线通信模块 nRF24L01 是一款使用 SPI 通讯协议， 通讯速率最高可达 8Mbps， 工作频率范围 2.400GHz～2.525GHz 的 单片无线收发器芯片。 ESP8266 Wifi 无线通信模块 ESP8266 是一款 Uart-Wifi 透传模块，可将用户的物理设备连接到 Wifi 无线网络上，进行互联网或局域网通信，实现联网功能。 SPP Bluetooth V3.0 无线通信模块（蓝牙） 默认通信使用蓝牙 V3.0 规范无线通信，使用 SPP 蓝牙串口协议，可实现 30 米蓝牙通信； 板载 MPU6050 六轴传感器进行姿态解算，内置 3 轴加速度计 + 3 轴陀螺仪； 支持超声波测量前方障碍物距离，实现简单的直线跟随功能和右转避障功能； 支持红外模块巡线功能，能识别白底黑线，实现简单的定速巡线功能； 支持 SPI 0.96 寸 OLED 显示模块，能显示小车倾斜角度、小车运行速度、超声波探测距离、电池电压等数据； 使用带编码器的直流减速电机，集成 384 线编码器，转速高达 260 RPM，扭矩高达 2.5kgf.cm； 使用 5C 动力锂电池，最大瞬时电流高达 10A，18650 封装安全性高，续航时间 3 小时（此时间与运动方式有关）； 使用 65MM 橡胶耐磨轮胎，内部填充海绵内胆，减震性能好，摩擦力大； console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A49.html":{"url":"A49.html","title":"装拆电池技巧","keywords":"","body":" 本小节介绍一个装、拆电池的小技巧。 装拆电池小技巧 （点击文字可转跳到视频网站） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A50.html":{"url":"A50.html","title":"电池充电技巧","keywords":"","body":" 本小节介绍一个电池充电的小技巧。 电池充电小技巧 （点击文字可转跳到视频网站） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A15.html":{"url":"A15.html","title":"蓝牙遥控模式","keywords":"","body":"蓝牙遥控 本小节教你如何使用「喵呜手机端」、「喵呜手机端简易版」（曾用名「平衡小车通用控制」）两款 APP，并对其中的功能进行说明。 视频版教程 （点击文字可转跳到视频网站） 文字版教程 我们在上一节中已经安装好了小车，并且在安卓手机中安装了「喵呜手机端」 和「喵呜手机端简易版」两款 APP。 喵呜手机端 我们先对专业级 APP ——「喵呜手机端」进行说明。「喵呜手机端」有 5 个界面，下面分别对这 5 个界面进行说明。5 个界面可以左右滑动屏幕进行切换。 重力感应界面 手机带有陀螺仪和加速度计才能使用重力感应功能。部分低端手机可能为了节省成本，不带有陀螺仪和加速度计，将无法使用重力感应功能。 Image 2.5.1 - 重力感应 初次打开 APP 时，你先看到的会是重力感应界面。界面上方有三个参数，有 Pitch、Roll、滤波器系数。其中， Pitch：代表手机前后倾斜的角度 Roll：代表手机左右倾斜的角度 滤波器系数：忽略 在重力感应界面，按住重力感应块，通过倾斜手机的角度就能控制小车的方向、速度。手机与地面平衡状态为 0 度。手机前后倾斜时为控制小车前进、后退，倾斜角度越大（即 Pitch 越大），前进、后退的速度越大。手机左右倾斜则为控制小车左转、右转，倾斜角度越大（即 Roll 越大），左转或右转的角度越大，当手机纯粹向左或向右倾斜时（此时 Pitch 为 0，Roll 不为 0），小车旋转角度为 360 度，即原地自旋。 摇杆控制 Image 2.5.2 - 摇杆控制 往左滑动，切换到摇杆控制界面。界面上方有 x、y 两个参数，x 代表摇杆左右推离中心的距离，y 代表摇杆前后推离中心的距离。紧接着 x、y 参数的下方，有 4 个控制模式可以切换，分别为： 遥控模式：只有在遥控模式下，才能使用重力感应和摇杆控制小车。 巡线模式：安装红外模块才能生效。在巡线模式下，小车跟随预设的黑线运动。 超声波跟随模式：安装超声波模块才能生效。在跟随模式下，小车自动判断与前方障碍物的距离，并通过运动与障碍物保持设定的距离。 超声波避障模式：安装超声波模块才能生效。在避障模式下，小车自动判断与前方障碍物的距离，并通过运动避开障碍物。 界面的下方为虚拟摇杆，按住并推动摇杆就能控制小车的方向、速度，松手后摇杆自动回中。摇杆推离中心越远，速度、转向角度就越大。当摇杆水平推至左侧或右侧（此时 y 为 0，x 不为 0），小车的旋转角度为 360 度，即原地自旋。 波形显示 Image 2.5.3 - 波形显示 波形显示界面的上方部分为波形显示窗口，下方有 3 个参数可以勾选，分别为： 加速度传感器：代表小车里加速度传感器初步经过 atan2 函数计算得到的角度值，未经过数据融合。 陀螺仪：代表小车里陀螺仪的数据，我们通常认为陀螺仪的输出就是角速度值。 Kalman filter：代表加速度传感器和陀螺仪数据融合后得到的角度值，即小车的实时倾斜角度值。 我们通常会全选以上 3 个参数，便于观察小车数据融合后的角度有没有噪声和延迟。 PID Image 2.5.4 - PID PID 界面上方有 2 个当前参数可以选择： 角度环 PID 速度环 PID 选择哪个控制环，则显示对应的 PID 参数。当前参数的下方有 P、I、D 3 个参数的显示值，此时显示的小车正在运行的 PID 参数。点击下方的「查询 PID 参数」就能将小车正在运行的 PID 参数显示到手机上。 接着，调节参数有 P、I、D 3 个滑轨可以调节，用于调节 PID 参数。滑动滑轨调节好参数后，点击下方的「更新 PID 参数」就能将滑轨参数实时更新至小车中。 查询 PID 参数：查询小车正在使用的 PID 参数，并将改组参数显示到手机上。 更新 PID 参数：调节滑轨的 PID 参数后，点击「更新 PID 参数」就能将滑轨参数实时更新至小车中，查看运行效果。 恢复默认参数：小车开机时的 PID 参数将被记录下来成为默认参数，如果改动后想恢复默认参数，只要点击恢复「恢复默认参数」就能恢复为开机时的参数。 关于 Image 2.5.5 - 状态查询 关于界面有 6 个参数，分别为： APP Version：APP 版本 Firmware Version：小车程序版本 EEPROM Version：EEPROM 版本 MCU：小车使用的 MCU 型号 电池电量：小车剩余电量 运行时间：小车开机后的运行时间 下方为 Start/Stop 按钮。点击按钮，可以实时获得以上 6 个参数数据。 喵呜手机端简易版 「喵呜手机端简易版」（曾用名「平衡小车通用控制」）界面简洁，只有选项和按钮。 Image 2.5.6 - 喵呜手机端简易版 先匹配小车蓝牙，然后点击更新蓝牙按钮，在下方白框中选择蓝牙设备，再点击连接蓝牙按钮，若连接成功，下方蓝牙状态显示为 true。连接未成功，蓝牙状态显示为 false。在 APP 中点击使用说明，能获取操作提示。 界面中间部分有 4 个控制模式可以切换，分别为： 遥控模式：只有在遥控模式下，才能使用重力感应和摇杆控制小车。 巡线模式：安装红外模块才能生效。在巡线模式下，小车跟随预设的黑线运动。 超声波跟随模式：安装超声波模块才能生效。在跟随模式下，小车自动判断与前方障碍物的距离，并通过运动与障碍物保持设定的距离。 超声波避障模式：安装超声波模块才能生效。在避障模式下，小车自动判断与前方障碍物的距离，并通过运动避开障碍物。 前进、后退、左转、右转 4 个按钮用于控制小车前进、后退、左转、右转。按住哪个按钮，可以获得对应操作，松开即停止。 点击退出程序按钮，退出 APP。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A34.html":{"url":"A34.html","title":"红外循迹模式","keywords":"","body":"红外循迹模式 本小节教你如何使用红外循迹模式，并教你如何根据场地调节红外模块的灵敏度电阻。 视频版教程 （点击文字可转跳到视频网站） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A35.html":{"url":"A35.html","title":"超声跟随模式","keywords":"","body":"超声跟随模式 本小节教你如何使用超声跟随模式，并对该功能进行简单的说明。 视频版教程 （点击文字可转跳到视频网站） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A36.html":{"url":"A36.html","title":"超声避障模式","keywords":"","body":"超声波避障模式 本小节教你如何使用超声波避障模式，并对该功能进行简单的说明。 视频版教程 （点击文字可转跳到视频网站） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A37.html":{"url":"A37.html","title":"提起识别","keywords":"","body":"提起识别 本小节对如何触发提起识别进行说明。 视频版教程 （点击文字可转跳到视频网站） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A38.html":{"url":"A38.html","title":"着陆识别","keywords":"","body":"着陆识别 本小节对如何触发着陆识别进行说明。 视频版教程 （点击文字可转跳到视频网站） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A39.html":{"url":"A39.html","title":"OLED显示说明","keywords":"","body":"OLED显示说明 本小节对 0.96 SPI OLED 显示屏中显示的参数分别代表什么进行说明。 行数 显示参数 表示内容 1 Mode:Complementary 互补滤波模式 2 Distance 超声波检测到前方障碍的距离 3 EncoLeft 左电机编码器数据（即左电机速度） 4 EncoRight 右电机编码器数据（即右电机速度） 5 Angle 车体倾斜角度 6 Battery 电池电压 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A48.html":{"url":"A48.html","title":"烧录程序指南（新）","keywords":"","body":"烧录程序指南 本小节教你如何使用 Micro-USB 和 Jlink-ob 烧录程序代码到小车里去。 如果是在 2020 年 08 月 01 日前购买的套件，请参考旧版烧录程序指南。 自 2020 年 08 月 01 日起，两轮自平衡小车「小霸王Lite」的 STM32 核心板升级添加了串口一键下载电路，同样的是适用 Micro-USB 数据线进行下载，与旧核心板相比，不同之处是不再需要反复设置 BOOT0 跳帽去配置高低电平，只需要配置好 MCUISP 软件就可以实现一键下载，一劳永逸。下面会对下载过程进行详细说明。 提示：建议用户认真阅读本节的每一行文字。 我们可以通过以下 2 种烧录（下载）方式，将程序代码烧录到两轮自平衡小车中： 使用 Micro-USB 数据线烧录程序。Micro-USB 数据线是套件标配的。 使用 SWD 烧录工具（JLink-ob、ST-Link 等）烧录程序。这些工具的使用喜好因人而异，套件并不配备，用户需要另行购买。 1.0 使用 Micro-USB 数据线烧录 1.1 硬件准备 两轮自平衡小车「小霸王Lite」 Micro-USB 数据线 电脑 1.2 软件工具 mcuisp.exe 烧录软件（资料包路径：/07、开发工具安装包/mcuisp.exe） CH340C USB to UART 芯片驱动（资料包路径：/07、开发工具安装包/CH340驱动/CH341SER.EXE） 1.3 操作步骤 本示例中使用 Windows 7 系统，如果你使用的是其他版本的系统，如 Windows 8、Windows 10，都可以使用该驱动。该驱动支持 32、64位 Windows 10 8.1 8 7 VISTA XP。 1.3.1 预安装 CH340 驱动 在资料包中找到 CH340 的驱动（资料包路径：/07、开发工具安装包/CH340驱动/CH341SER.EXE） ，直接双击运行进行安装。双击后会显示以下提示运行窗口，点击“运行”。 Image 2.12.1 - 提示运行窗口 alt > 接着，会出现驱动安装界面，如下图所示。我们点击“安装”。 Image 2.12.2 - 驱动安装界面 alt > 驱动会自动安装完成。然后提示“驱动预安装成功”。 Image 2.12.3 - 驱动预安装成功 alt > 这就完成了驱动的预安装。但我们需要在实际使用中检验驱动是否真的安装成功。 1.3.2 检验驱动安装 使用 Micro-USB 数据线连接电脑和小车，在电脑桌面上左键点击「我的电脑」，右键点击「属性」，再在面板上点击「设备管理器」，在 「端口（COM和LPT）」 中可以找到分配的 COM 口。如果显示 COM 口，则表示驱动程序已经正常安装。示例截图为 COM4。 1.3.3 使用 mcuisp.exe 烧录 在资料包中找到 mcuisp.exe 烧录软件（资料包路径：/07、开发工具安装包/mcuisp.exe） ，双击运行该软件。如果你是第一次使用该软件，此时可以看到该软件的默认界面设置，如下图所示： Image 2.12.4 - mcuisp.exe 默认界面设置 alt > 我们要对 mcuisp.exe 烧录软件进行简单的设置，以实现一键下载。所谓一键下载，就是插上数据线后，只需要点击 “开始编程(P)” 按钮就可以实现下载，再也不用对 BOOT0 进行设置。具体的设置，主要就是设置成“DTR低电平复位，RTS高电平进Bootloader，如下图所示。Port 口要选择我们使用的 COM 口，在这里我们是分配到了 COM4，所以选择 COM4。bps 即波特率，我们常用 115200，波特率越高，下载速度越快。在实际测试中，我们将波特率设置成最高的 460800 都可以稳定下载。至于烧录 hex 代码文件，我们在这里是选择了小车的出厂代码，资料包里有该代码，资料包路径：/02.源代码/Mwbalanced-stm32-小霸王Lite-firmware-互补滤波-none V3.3/Output/BasicBalance.hex。 Image 2.12.5 - mcuisp.exe 一键下载设置 alt > 点击 mcuisp.exe 软件的「开始编程(P)」 按钮，就会自动开始烧录代码。如下图所示。 Image 2.12.6 - 自动烧录代码中 alt > 代码烧录完毕。提示「命令执行完毕，一切正常」。如下图所示。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A06.html":{"url":"A06.html","title":"烧录程序指南（旧）","keywords":"","body":"烧录程序 本小节教你如何使用 Micro-USB 和 Jlink-ob 烧录程序代码到小车里去。建议认真阅读每一行文字。 自2019年1月1日起购买「小霸王Lite」的小伙伴，可参照本节方法烧录代码。 「小霸王Lite」两轮自平衡小车支持 2 种烧录方式： 使用套件配套的 Micro-USB 数据线烧录 使用萌新自备的 SWD 烧录工具（JLink-ob、ST-Link等）烧录 下面分别对以上两种烧录方式进行详细的说明。 使用 Micro-USB 数据线烧录 硬件设备 「小霸王Lite」两轮自平衡小车 Micro-USB 数据线 电脑 软件工具 mcuisp.exe 烧录软件 CP2102 USB to UART 芯片驱动 相关链接 CP2102 官方驱动：官方驱动 操作步骤 本示例中使用 Windows 7 系统，如果你使用的是其他版本系统（Windows 8、Windows 10 等），请点击上面的相关链接转跳至 CP2102 官网中下载对应的驱动程序。 （一）安装 CP2102 驱动 在 光盘/07.开发环境及烧录工具/CP210x_Windows_Drivers_with_Serial_Enumeration.zip 中找到 CP2102 驱动，并对其进行解压，得到 CP210xVCPInstaller_x86.exe、CP210xVCPInstaller_x64.exe 两个可执行文件。然后，在电脑桌面找到并且鼠标左键点击选中「我的电脑」图标，右键选中点击「属性」，查看电脑系统类型。如果电脑系统类型是「64 位操作系统」，则双击CP210xVCPInstaller_x64.exe 进行驱动安装；如果电脑系统类型是「32 位操作系统」，则双击 CP210xVCPInstaller_x86.exe 进行驱动安装。接着，开始进入自动安装界面。 进入驱动安装界面，点击「下一步」。 选择「我接受这个协议」，点击「下一步」。 进入自动安装环节，过几秒后，提示「此计算机上成功安装了此驱动程序」。 来到这一步，CP2102 USB to UART 芯片的驱动程序理论上是已经成功安装了。 Image 2.13.1 - 连接数据线 但是，我们还需确认驱动程序是否已经正常安装。用 Micro-USB 数据线连接电脑和小车，在电脑桌面上左键点击「我的电脑」，右键点击「属性」，再在面板上点击「设备管理器」，在 「端口（COM和LPT）」 中可以找到小车使用的 COM 口。如果显示 COM 口，则表示驱动程序已经正常安装。示例截图为 COM1。 （二）使用 mcuisp.exe 软件进行烧录 在 光盘/07.开发环境及烧录工具/mcuisp.exe 中找到 mcuisp.exe 软件，并且双击打开该软件。 首次打开 mcuisp.exe 的界面。 点击 mcuisp.exe 软件上层菜单栏的「搜素串口」，然后在「Port」选择对应串口，示例为 COM1。波特率选择 115200bps。选择烧录 hex 代码文件，示例选择为 光盘/02.源代码/Mwbalanced-stm32-小霸王Lite-firmware-互补滤波-none V3.3/Output/BasicBalance.hex，其他设置默认即可。 接着，把小车的 STM32 控制板上的 BOOT0 跳帽跳到 1 端，即高电平端。这个步骤非常重要，如果跳帽没跳到高电平端，是烧录不进去的。 再点击 mcuisp.exe 软件的「开始编程」 按钮，按一下核心板的复位按钮，就会检测到芯片，并且开始烧录代码。 代码正在烧录中。 代码烧录完毕。提示「命令执行完毕，一切正常」。 （三）BOOT0 跳回 0 端，小车重新上电 至此，代码已经成功烧录到「小霸王Lite」两轮自平衡小车上啦。这时候萌新们可能会心情激动万分，终于烧录进去代码了，但却发现小车怎么好像没反应？因为我们还没有把 BOOT0 跳帽跳回 0 端，程序还无法运行。我们只要把小车控制板上的 BOOT0 跳帽跳回 0 端，再重新上电或者按一下控制板的复位按钮，就能看到程序烧录进小车里的运行效果啦。 JLink-ob 烧录代码 硬件设备 「小霸王Lite」两轮自平衡小车 JLink-ob 电脑 软件工具 MDK-ARM 5.17 使用 JLink-ob 下载需要先安装好 MDK-ARM 软件。 操作步骤 使用 Jlink-ob 烧录时，对应 JLink-ob 和 STM32 控制板上的接口丝印，并将 JLink-ob 的 SWD 四线插到 STM32 控制板的 SWD 排针上。 然后，点击 MDK-ARM 左上角快捷工具栏中的 Load 按钮（或者选项菜单中选择Flash-Download），就可以把编译好的代码程序烧录到芯片中去。 Image 2.13.2 - MDK界面 烧录成功之后，会在 MDK-ARM 下方的Build Output框中出现一段提示。 Image 2.13.3 - MDK界面 至此，烧录已经成功，程序一般会自动运行。JLink-ob 提供的电流不足以驱动电机转动，我们把电池装好，开机上电，就能看到代码在小车里的运行情况啦。如果你发现程序没有运行，那是很大可能是因为我们在设置中没有选上自动运行，这时需要手动复位，按一下控制板上的复位按键或者重新上电，程序就会运行。如果觉得每次手动复位太麻烦，我们还可以设置一下，在 MDK-ARM 开发环境中点击 Target Options…->Debug->Setting->Flash DownLoad，把 Reset and Run 选项打勾选上，烧录完代码就会自动复位并运行程序。 Image 2.13.4 - MDK界面 如果在下载时出错，提示检测不到 JTAG，那是因为 JLink-ob 使用的是 SWD，这时要依次点击Target Options…->Debug->Setting->J-Link/J-Trace Adapter，在 ort 选择栏将默认的 JTA 更改选择 SW 。 Image 2.13.5 - MDK界面 选择烧录工具为 JLINK/J-TRACE Cortex。 Image 2.13.6 - MDK界面 将 JTAG 更改选择 SW 。 资料包里的程序工程默认的 SWD 烧录器是设置为 JLink，所以，我们能直接使用 JLink-ob 烧录代码，如果想使用ST-Link ，那么需要在 Target Options…->Debug 将 JLINK/J-TRACE Cortex 改成 ST-Link Debugger 或其他。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A18.html":{"url":"A18.html","title":"修改遥控APP","keywords":"","body":"编写APP 本小节教你如何快速修改「喵呜手机端简易版」APP（曾用名「平衡小车通用控制」APP）的名称，打造属于自己的专属 APP。 由于篇幅有限，本小节暂时只对修改 APP 名称进行说明，并不能从零开始地进行教学。 App Inventor 是一个完全在线的 Android 图形化编程环境，起初由 Google 研发、设计，后来移交给 MIT 发布、维护。萌新们可理解 App Inventor 为一个网站，一个能开发 Android APP 的网站，开发一个 App Inventor 程序就从你的浏览器开始。 App Inventor 抛弃传统复杂的程式代码，而使用积木式的堆叠法来编写 Android APP，为此，App Inventor 在中小学编程教育中大受欢迎。与使用 Java 编程相比较，使用 App Inventor 编程更加容易学习，毕竟小学生都能轻松上手，更何况基础功底更好的大学生呢。对于没有编程基础、时间紧迫的毕设党竞赛党学生党而言，这无疑是一大福音。「喵呜手机端简易版」APP 正是使用 App Inventor 编写而成。 （一）注册帐号 打开 MIT App Inventor 广州站官网（app.gzjkw.net），注册帐号，并登录。 （二）导入项目。 点击页面上方项目-导入项目（.aia），然后弹出导入项目界面。 在导入项目界面中选择 光盘/03.APP/MiaowLabs_APP_Lite_v2.aia ，选择 aia 源文件后，点击确定按钮。 （三）修改APP名称。 导入并打开项目后，首先看到的是项目的组件设计界面。组件设计界面中又分为组件面板、工作面板、组件列表、组件属性四大界面。 保持其他的地方不变动，我们在 组件属性-应用名称 和 标题 中分别修改APP的名称，比如修改成张三的APP。 此时，就完成了修改APP名称和标题，可以点击 打包apk-打包apk并下载到电脑，然后在手机上安装apk，测试是否已经改名成功。 （四）修改通信协议。 如果你想要改成自己的通信协议，可以点击右上角的逻辑设计，切换到逻辑设计界面，然后自由发挥，修改通信协议。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A29.html":{"url":"A29.html","title":"修改开机模式","keywords":"","body":"修改模式 本小节教你修改代码，更改小车的开机模式。出厂默认的开机模式为遥控模式。共有四种模式（遥控模式、红外循迹模式，超声波避障模式，超声波跟随模式）提供选择。 需要安装 MDK5.17，或以上版本。没安装的同学可以参考《安装MDK-ARM软件》小节。 双击 BasicBalance.uvprojx工程文件，使用 MDK-ARM 软件打开工程，然后在工程左侧的 USER 文件夹下找到 manage.h 头文件和 manage.c 源文件，它们的主要功能是配置开机模式。 Image 2.15.1 - 修改模式 在 manage.h 头文件中，定义了几个宏定义： #define CONTROL_MODE 1 //遥控模式 #define INFRARED_TRACE_MODE 2 //红外寻迹模式 #define ULTRA_FOLLOW_MODE 3 //超声波跟随模式 #define ULTRA_AVOID_MODE 4 //超声波避障模式 在 manage.c 中我们能找到配置相关的语句： unsigned char g_CarRunningMode = CONTROL_MODE; //默认为遥控模式 通过修改该语句就可以修改小车的开机工作模式。比如，我想让小车开机就是工作在红外寻迹模式，那么可以这样修改： unsigned char g_CarRunningMode = INFRARED_TRACE_MODE;//红外寻迹模式 比如，我想让小车开机就是工作在超声波避障模式，那么可以这样修改： unsigned char g_CarRunningMode = ULTRA_AVOID_MODE;//超声波避障模式 修改完代码之后，重新编译代码，并烧录进小车里，就能更改想要的开机工作模式。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"B04.html":{"url":"B04.html","title":"硬件组成概述","keywords":"","body":"硬件组成 本小节对「小霸王Lite」两轮自平衡小车的硬件组成进行简单说明，并给出购买链接。 硬件划分为两大部分： 电路模块 其他部件 电路硬件 以标准版（官方标配）为例，主要的电路模块有： MiaowLabs-STM32F1-Micro 核心板 MiaowLabs-MPU-6050 传感器模块 MiaowLabs-TB6612FNG 驱动模块 MiaowLabs-5v/3.3v 稳压模块 MiaowLabs-BT-06 蓝牙模块 MiaowLabs-Lite 底板 增强版包含标准版的所有电路模块，还包含以下的电路模块： MiaowLabs-超声波模块 MiaowLabs-四路红外模块 MiaowLabs-0.96OLED 模块 其他部件 TTM2 带编码器的直流减速电机 x 2 竖直型铝合金电机固定部件 x 2 超高品质大摩擦橡胶轮胎 x 2 18650 动力锂电池 x 2 亚克力支撑板 隔离柱 螺丝 螺母 模块分布 Image 2.16.1 - 模块分布 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A46.html":{"url":"A46.html","title":"IO引脚分配","keywords":"","body":"IO引脚分配 为了让大家更快更好的使用「小霸王Lite」两轮自平衡小车，这里特地将「小霸王Lite」主芯片 STM32F103C8T6 的 IO 资源分配做了一个总表，以便大家查阅。「小霸王Lite」两轮自平衡小车的 IO 引脚分配总表： 引脚 GPIO 连接资源 独立 连接关系说明 10 PA0 TIM2_CH1 Y 连接编码器，PA0 与 PA1 组成正交解码接口 11 PA1 TIM2_CH2 Y 连接编码器，PA0 与 PA1 组成正交解码接口 12 PA2 Trig Y 超声波模块接口的 Trig 脚 13 PA3 BIN1 Y TB6612FNG 驱动模块接口的 BIN1 脚 14 PA4 BIN2 Y TB6612FNG 驱动模块接口的 BIN2 脚 15 PA5 BAT Y 稳压模块接口的 AD 脚 16 PA6 TIM3_CH1 Y TB6612FNG 驱动模块接口的 PWMA 脚 17 PA7 TIM3_CH2 Y TB6612FNG 驱动模块接口的 PWMB 脚 29 PA8 Rb / MISO N 1、红外模块接口 Rb 脚；2、nRF24L01 模块接口 MISO 脚 30 PA9 USART1_TX Y 串口 1 TX 脚，默认连接核心板的 USB-TTL 芯片的 RX 脚 31 PA10 USART1_RX Y 串口 1 RX 脚，默认连接核心板的 USB-TTL 芯片的 TX 脚 32 PA11 Echo / Button N 1、超声波模块接口的 Echo 脚；2、默认连接核心板的用户按键 33 PA12 ESP_GPIO0 / SCK N 1、ESP8266 模块接口 ESP_GPIO0 脚；2、nRF24L01 模块接口 SCK 脚 34 PA13 SWDIO Y SWD 仿真口的 SWDIO 脚 37 PA14 SWCLK Y SWD 仿真口的 SWCLK 脚 38 PA15 ESP_GPIO2 / Ra / CE N 1、ESP8266 模块接口 ESP_GPIO2 脚；2、红外模块接口的 Ra 脚；3、nRF24L01 模块接口 CE 脚 18 PB0 AIN1 Y TB6612FNG 驱动模块接口的 AIN1 脚 19 PB1 AIN2 Y TB6612FNG 驱动模块接口的 AIN2 脚 20 PB2 BOOT1 Y BOOT1，启动选择配置引脚，默认接 GND 39 PB3 ESP_CH_PD / Lb / IRQ N 1、ESP8266 模块接口 ESP_CH_PD 脚；2、红外模块接口的 Lb 脚；3、nRF24L01 模块接口 IRQ 脚 40 PB4 ESP_RST / MOSI N 1、ESP8266 模块接口 ESP_RST 脚；2、nRF24L01 模块接口 MOSI 脚 41 PB5 La / CSN N 1、红外模块接口的 La 脚；2、nRF24L01 模块接口 CSN 脚 42 PB6 TIM4_CH1 Y 连接编码器，PB6 与 PB7 组成正交解码接口 43 PB7 TIM4_CH2 Y 连接编码器，PB6 与 PB7 组成正交解码接口 45 PB8 I2C1_SDA Y MPU-6050 模块接口的 SDA 脚 46 PB9 I2C1_SCL Y MPU-6050 模块接口的 SCL 脚 21 PB10 ESP_TXD / Bluetooth_TX N 串口3 TX 脚：1、ESP8266 模块接口 ESP_TXD 脚；2、连蓝牙模块接口的 RX 22 PB11 ESP_RXD / Bluetooth_RX N 串口3 RX 脚：1、ESP8266 模块接口 ESP_RXD 脚；2、连蓝牙模块接口的 TX 25 PB12 LED Y 默认连接核心板上的蓝色 LED 指示灯 26 PB13 OLED_RST Y 0.96 OLED 显示模块接口的 RST 脚 27 PB14 OLED_SDA Y 0.96 OLED 显示模块接口的 SDA 脚 28 PB15 OLED_SCL Y 0.96 OLED 显示模块接口的 SCL 脚 2 PC13 OLED_DC Y 0.96 OLED 显示模块接口的 DC 脚 3 PC14 OSC32_IN N 接 32.768K 晶振，不可用作 IO 4 PC15 OSC32_OUT N 接 32.768K 晶振，不可用作 IO 5 PD0 OSC_IN N 接 8M 晶振，不可用作 IO 6 PD1 OSC_OUT N 接 8M 晶振，不可用作 IO 7 NRST N 复位脚，不可用作 IO 44 BOOT0 N BOOT0，启动选择配置引脚（仅上电时用） 上表中，引脚栏即 STM32F103C8T6 的引脚编号； GPIO 栏则表示 GPIO；连接资源栏 表示了对应 GPIO 所连接到的网络；独立栏，表示该 IO 是否可以完全独立（只接一种外设 或上下拉电阻）使用，Y 表示可做独立 IO， N 表示不可做独立 IO；连接关系栏，则对每个 IO 的连接做了简单的介绍。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A19.html":{"url":"A19.html","title":"软件功能说明","keywords":"","body":"软件功能 本小节对「小霸王Lite」两轮自平衡小车的软件功能进行简单说明。 两轮自平衡小车的关键点在于保持自平衡，程序中的首要任务，就是优先保障小车的直立平衡，即其他功能任务都是在不干扰直立平衡的情况下进行添加。 Image 2.18.1 - 「小霸王Lite」两轮自平衡小车软件流程图 「小霸王Lite」两轮自平衡小车的程序的主要功能包括： 程序初始化； 对传感器数据、编码器脉冲数据进行读取、处理； 直立控制、速度控制、方向控制； 计算 PWM 输出控制电机； 其他辅助功能：蓝牙遥控、超声波读取、红外信号处理、显示屏刷新、上位机监控等。 上述功能可以分成两大类：第一类包括 2、3、4 功能，它们属于需要精确时间周期执行，因此可以放在一个周期定时中断里完成。第二类包括 1、5 功能，它们的执行不需要精确的时间周期。可以放在程序的主程序中完成。这两类任务之间可以通过全局变量实现相互的通讯。 两轮自平衡小车上电运行后，单片机进行初始化。初始化的工作包括两部分：第一部分是对于各个应用到的模块进行初始化；第二部分是控制程序初始化，是对两轮自平衡小车控制程序中应用到的变量值进行初始化。 初始化完成后，首先进入小车直立平衡检测子程序。该程序通过角度判断车体是否处于可控角度范围内，如果处于可控范围，则立刻启动车体直立控制、速度控制、方向控制以及电机输出。如果不处于可控范围，则一直等待，直到符合条件。 程序在主循环中不停发送监控数据，通过串口与蓝牙模块进行全双工通信，将数据发送到手机或电脑进行监控。同时，在主循环中接受来自手机或手机的要控制指令。 小车的直立控制、速度控制、方向控制以及电机输出都是在定时中断程序中完成。通过全局标志变量确定是否进行这些闭环控制。提起识别、着陆识别、跌倒识别功能函数同样放在中断里，一旦检测到车体失控，则停止电机输出，直至重新符合直立条件。 因为大部分定时器我们都另有他用，于是我们使用 STM32 的滴答定时器，产生 1 毫秒定时中断。中断服务程序的任务被均匀分配在 0~4 的中断片段中，所有中断片段全部执行一遍需要 5ms。因此每个中断片段中的任务执行的频率为 200Hz，即 5ms。 将任务分配到不同的中断片段中，一方面防止这些任务累积执行时间超过 1ms，扰乱 1ms 中断的时序，同时也考虑到这些任务之间的时间先后顺序。当然，也可以将所有的中断任务都合并在一起，使用一个 5ms 的定时中断来完成。 这些任务包括： 电机测速脉冲计数器读取与清除。累积电机转动角度。累积电机速度，为后面速度控制提供平均数。 读取传感器的加速度数据、陀螺仪数据。 直立控制过程，包括姿态角度计算、直立控制计算。 速度控制过程，在这个 1ms 时间片段中，又进行 0~5 计数。在其中第 0 片段中，进行速度 PID 调节。因此，速度调节的周期为 5×5=25 毫秒，也就是每秒钟调节 40次。 方向控制过程，根据 APP 或上位机控制指令（或寻迹时读取红外传感器数值等），计算偏差数值，然后计算电机差速控制输出。 电机使能与失能控制，包括提起识别（悬空检测）、着陆检测、跌倒检测等。 电机输出，融合直立控制、速度控制、方向控制叠加值，最终赋予电机输出。 以上每个中断任务都占用不同的时间，上文中提到，我们设定一个 1ms 定时中断，让这些任务分配在各自的1ms内执行，划分了 0~4 共 5 个 1ms 时间片段，全部任务执行一遍需要 5ms。在程序调试时，需要保证它们都不会超过 1ms。每个任务具体执行时间可以通过示波器测量单片机 IO 引脚电平翻转得到，设定执行某任务前单片机的指定 IO引脚为低电平，执行完任务后，引脚电平翻转为高电平。 从上面任务中断时间波形可以得到每个任务消耗的时间： 在中断退出之后，程序继续回到主程序往下执行，完成蓝牙通信和监控调试等工作。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A30.html":{"url":"A30.html","title":"程序框架介绍","keywords":"","body":"程序框架 本小节对程序框架和运行流程进行说明。 打开 MiaowLabs两轮自平衡小车「小霸王Lite」光盘\\02、程序源代码\\Mwbalanced-stm32-小霸王Lite-firmware-互补滤波-none V3.33\\BasicBalance.uvprojx 工程文件，展开工程分组如下图所示： Image 2.19.1 - 工程分组 如图所示，可以看到工程分有 6 个分组，其中 FWlib 分组主要是 HAL 库的文件代码，CMSIS 分组主要是 Cortex-M3 核心的文件代码，Startup 分组是 stm32f10x 的启动文件代码，BSP 分组主要是外设硬件的驱动程序代码，比如 MPU6050、oled 等，SYS 分组主要是滴答定时器和调试相关的配置代码，USER 分组是用户代码。 下面我们先讲解一下 USER 分组的 main.c。main.c 包含了所有硬件初始化和参数初始化代码。初始化代码如下： int main(void) { BspInit(); //初始化BSP PIDInit(); //初始化PID CarUpstandInit();//初始化系统参数 SysTick_Init(); //初始化定时器 if(IsInfrareOK())//检测是否悬挂红外模块 g_iGravity_Offset = 1; //如果检测到悬挂红外模块，则更改偏移值。 ShowHomePageInit();//初始化OLED显示屏主页 while (1)//进入主循环 { SecTask();//秒级任务，主要是记录小车运行时间、读取电池电压等非实时任务 if(SoftTimer[1] == 0)//系统软件定时器1，分辨率为1ms，递减计数 {// 每隔20ms 执行一次 SoftTimer[1] = 20; ResponseIMU();//上报姿态数据到APP DebugService(); //上位机调试数据发送 Parse(Uart3Buffer); //APP数据解析函数 } if(SoftTimer[2] == 0)//系统软件定时器2，分辨率为1ms，递减计数 {// 每隔20ms 执行一次 SoftTimer[2] = 20; ShowHomePage();//刷新OLED页面 Read_Distane();//读取超声波测距距离 if(g_CarRunningMode == ULTRA_FOLLOW_MODE){ if(IsUltraOK())UltraControl(0); //设置超声波跟随模式 } if(g_CarRunningMode == ULTRA_AVOID_MODE){ if(IsUltraOK())UltraControl(1); //设置超声波避障模式 } else if(g_CarRunningMode == INFRARED_TRACE_MODE){ TailingControl();//设置红外循迹模式 } } } } 初始化代码主要是硬件底层驱动和系统参数的初始化。下面我们来讲解一下功能函数的具体作用。 BspInit 主要是硬件底层驱动的初始化，包括 STM32 外设的初始化、外围模块比如 MPU-6050 的初始化。具体见下面代码： void BspInit(void) { SWDConfig(); //SWD 调试接口配置，使能 SWD，失能 JTAG ADCInit(); //ADC 初始化 USART1Init(); //串口 1 初始化-底板预留下载及调试用 USART3Init(0); //串口 3 初始化-用于蓝牙 TIM1_Cap_Init(); //TIM1初始化-用于超声波跟随功能 TIM3_PWM_Init(); //PWM初始化 TIM2_Encoder_Init(); //TIM2 正交解码初始化-用于测速 TIM4_Encoder_Init(); //TIM4 正交解码初始化-用于测速 i2cInit(); //I2C 初始化 InfraredIOInit(); //红外 IO 口初始化 OLED_Init(); //OLED 初始化 MPU6050_Init(); //MPU6050 初始化 LEDInit(); //指示灯初始化 UltraSelfCheck(); //超声模块开机自检 InfrareSelfCheck(); //红外模块开机自检 delay_ms(500); //延时 0.5s，等待蓝牙模块启动 Uart3SendStr(\"\\r\\nAT+BAUD8\\r\\n\"); //配置蓝牙串口波特率为 115200 ( 原波特率9600 ) USART3Init(1); //更改 UART3 波特率为 115200 delay_ms(20); //延时 20ms,等待波特率稳定 SetBlueToothName(); //配置蓝牙模块名称 } PIDInit 主要是小车系统的 PID 参数初始化。 CarUpstandInit 主要是小车系统的各种参数初始化。 SysTick_Init 是系统滴答定时器 SysTick 的初始化，在这里设置为 1ms 中断一次。 if(IsInfrareOK()) g_iGravity_Offset = 1; 检测是否悬挂红外循迹模块，如果有则需要修改重心偏移值。因为在一侧悬挂红外后，小车重心会偏移。 ShowHomePageInit 主要是在 OLED 显示 logo。 while(1) 主循环中主要是执行一些非实时任务（早些迟些执行都无所谓的任务），人为定义一个秒级任务，轮询执行这些任务。这些非实时任务有上报数据、调试数据、解析协议、刷新 OLED 数据、读取距离等。 执行完初始化，代码会由于滴答定时器 SysTick 进入中断而转跳到 SysTick 定时中断服务函数中执行。在 stm32f10x_it.c 中可以找到 SysTick_Handler 定时中断服务函数。代码具体内容如下： void SysTick_Handler(void) { SoftTimerCountDown(); //软定时器 g_u8MainEventCount++; //主事件计数变量 g_u8SpeedControlPeriod++; //速度环控制周期计数变量 SpeedControlOutput(); //速度环控制输出函数，每1ms执行一次 if(g_u8MainEventCount>=5) //5ms进入一次 { g_u8MainEventCount=0; GetMotorPulse(); //捕获电机脉冲（速度）函数，每5ms执行一次 } else if(g_u8MainEventCount==1) { MPU6050_Pose(); //读取MPU6050数据函数，每5ms执行一次 AngleCalculate(); //角度环计算函数，每5ms执行一次 } else if(g_u8MainEventCount==2) { AngleControl(); //角度环控制函数，每5ms执行一次 } else if(g_u8MainEventCount==3) { g_u8SpeedControlCount++; if(g_u8SpeedControlCount >= 5)//25ms { SpeedControl(); //车模速度控制函数，每25ms调用一次 g_u8SpeedControlCount=0; g_u8SpeedControlPeriod=0; } } else if(g_u8MainEventCount==4) { MotorManage(); //电机使能/失能控制函数，每5ms执行一次 MotorOutput(); //电机输出函数，每5ms执行一次 } } SoftTimerCountDown 是软定时器在 SysTick 中断中得到精确的递减。 g_u8MainEventCount 是主事件计数变量。我们需要在中断中运行的代码，在 1ms 内运行不完，所以需要主事件计数变量将代码合理分段，放到 5 个 1ms 内运行。 g_u8SpeedControlPeriod 是速度环的控制周期计数变量。 在 5ms 内执行 GetMotorPulse、MPU6050_Pose、AngleCalculate、AngleControl、MotorManage、MotorOutput，而速度环是 25ms 运行一次。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A47.html":{"url":"A47.html","title":"波形调试分析","keywords":"","body":"波形调试分析 本小节教你如何使用喵呜地面站调试波形。 波形调试分析视频教程 （点击文字可转跳到视频网站） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A31.html":{"url":"A31.html","title":"分析排除故障","keywords":"","body":"排除故障 故障现象 产生原因 解决方法 不通电，核心板红灯不亮 电池装反，或稳压模块装反，或长时间装反电池后烧断底板线路 检测电池、稳压模块的安装。如果电池、稳压模块都没问题，则可能是底板线路问题，寄回售后检测返修。 核心板蓝灯不闪烁，芯片发烫 主控芯片故障，或核心板故障 更换芯片，或更换核心板 核心板蓝灯闪烁，电机不动，驱动模块发烫 驱动模块故障 更换驱动模块 发生故障按照以上方法无效时，应立即与客服人员联系，切勿自行维修、焊接，以免发生危险。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A40.html":{"url":"A40.html","title":"平衡原理","keywords":"","body":"平衡原理 控制小车平衡的直观经验来自于人们日常生活经验。一般的人通过简单练习就可以让一个直木棒在手指尖上保持直立。这需要两个条件：一个是托着木棒的手掌可以移动； 另一个是眼睛可以观察到木棒的倾斜角度和倾斜趋势（角速度）。通过手掌移动抵消木棒的倾斜角度和趋势，从而保持木棒的直立。这两个条件缺一不可，实际上就是控制中的负反馈机制。 世界上还没有任何一个天才杂技演员可以蒙着眼睛使得木棒在自己指尖上直立，因为没有了眼睛观察进行负反馈。 Image 3.1.1 - 保持木棒直立的反馈控制 alt > 小车平衡控制也是通过负反馈来实现的，与上面保持木棒直立比较则相对简单。因为小车有两个轮子着地，车体只会在轮子滚动的方向上发生倾斜。控制轮子转动，抵消在一个维度上倾斜的趋势便可以保持车体平衡了。 Image 3.1.2 - 通过车轮运动保持小车平衡 alt > 那么车轮如何运行，才能够最终保持车体平衡稳定？为了回答这个问题，可以通过建立两轮自平衡小车的运动学和动力学数学模型，设计反馈控制来保证车体的平衡。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A42.html":{"url":"A42.html","title":"动力学分析","keywords":"","body":"动力学分析 为了使得同学们能够比较清楚理解其中的物理过程。下面通过对比单摆模型来说明保持车体平衡的控制规律。 重力场中使用细线悬挂着重物经过简化便形成理想化的单摆模型。直立着的小车可以看成放置在可以左右移动平台上的倒立着的单摆。 Image 3.2.1 - 小车简化成倒立的单摆 alt > 对普通的单摆受力分析。 Image 3.2.2 - 普通单摆受力分析 alt > 当物体离开垂直的平衡位置之后，便会受到重力与悬线的作用合力，驱动重物回复平衡位置。这个力称之为回复力，其大小为 F=−mgsinθ≈−mgθF=-mgsin \\theta \\approx -mg \\theta F=−mgsinθ≈−mgθ 在偏移角度很小的情况下，回复力与偏移的角度之间大小成正比，方向相反。 在此回复力作用下，单摆便进行周期运动。在空气中运动的单摆，由于受到空气的阻尼力， 单摆最终会停止在垂直平衡位置。空气的阻尼力与单摆运动速度成正比，方向相反。阻尼力越大，单摆越会尽快在垂直位置稳定下来。 不同阻尼系数下，单摆的运动曲线也不同。 Image 3.2.3 - 不同阻尼力下的单摆运动 alt > 总结单摆能够稳定在垂直位置的条件有两个： 受到与位移（角度）相反的恢复力； 受到与运动速度（角速度）相反的阻尼力。 如果没有阻尼力，单摆会在垂直位置左右摆动。阻尼力会使得单摆最终停止在垂直位置。阻尼力过小（欠阻尼）会使得单摆在平衡位置附件来回震荡。阻尼力过大（过阻尼）会使得单摆到达平衡位置时间加长，比如气球单摆。因而存在一个临界阻尼系数，使得单摆稳定在平衡位置的时间最短。 为什么倒立摆在垂直位置时，在受到外部扰动的情况下，无法保持稳定呢？我们来分析倒立摆的受力。 Image 3.2.4 - 在车轮上的参照系中小车受力分析 alt > 倒立摆之所以不能象单摆一样可以稳定在垂直位置，就是因为在它偏离平衡位置的时候，所受到的回复力与位移方向相同，而不是相反！因此，倒立摆便会加速偏离垂直位置，直到倒下。 如何通过控制使得倒立摆能够像单摆一样，稳定在垂直位置呢？要达到这一目的，只有两个办法：一个是改变重力的方向；另一个是增加额外的受力，使得恢复力与位移方向相反才行。显然能够做到的只有第二种方法。 控制倒立摆底部车轮，使得它作加速运动。这样站在小车上（非惯性系，以车轮作为坐标原点）分析倒立摆受力，它就会受到额外的惯性力，该力与车轮的加速度方向相反，大小成正比。这样倒立摆所受到的回复力为： F=mgsinθ−macosθ≈mgθ−mk1θ\r F=mgsin \\theta -macos \\theta \\approx mg \\theta -mk_1 \\theta\r F=mgsinθ−macosθ≈mgθ−mk​1​​θ ​ （2-1） 式中，由于θ\\thetaθ很小，所以进行了线性化。假设负反馈控制是车轮加速度α\\alphaα与偏角θ\\thetaθ成正比，比例为k1k_1k​1​​ 。如果比例k1>gk_1>gk​1​​>g （ ggg是重力加速度），那么回复力的方向便于位移方向相反了。 此外，为了使得倒立摆能够尽快地在垂直位置稳定下来，还需要增加阻尼力。虽然存在着空气和摩擦力等阻尼力，相对阻尼力比较小。因此需要另外增加控制阻尼力。增加的阻尼力与偏角的速度成正比，方向相反。因此式（2-1）可变为 F=mgθ−mk1θ−mk2θ1F=mg \\theta -mk_1 \\theta -mk_2 \\theta ^1F=mgθ−mk​1​​θ−mk​2​​θ​1​​ （2-2） 按照上面的控制方法，可把倒立摆模型变为单摆模型，能够稳定在垂直位置。因此，可得控制车轮加速度的控制算法 a=k1θ+k2θ1a=k_1 \\theta+k_2 \\theta ^1a=k​1​​θ+k​2​​θ​1​​ （2-3） 式中，θ\\thetaθ 为车体倾角；θ1\\theta ^1θ​1​​为角速度；k1 k_1k​1​​、k2k_2 k​2​​均为比例系数；两项相加后作为车轮加速度的控制量。只要保证在k1>gk_1>gk​1​​>g、k2>0k_2>0k​2​​>0条件下，可以使得车体像单摆一样维持在直立状态。其中有两个控制参数k1k2k_1 k_2k​1​​k​2​​，k1k_1k​1​​决定了车体是否能够稳定到垂直平衡位置，它必须大于重力加速度；k2k_2k​2​​决定了车体回到垂直位置的阻尼系数，选取合适的阻尼系数可以保证车体尽快稳定在垂直位置。 Image 3.2.5 - 小车控制两个系数作用 alt > console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A43.html":{"url":"A43.html","title":"数学建模","keywords":"","body":"数学建模 在上面简单分析中，通过类比倒立摆得到了小车直立的控制方案。下面对两轮自平衡小车进行简单数学建模，然后建立速度的比例微分负反馈控制，根据基本控制理论讨论小车通过闭环控制保持稳定的条件。 假设两轮自平衡小车简化成高度为LLL，质量为mmm的简单倒立摆，它放置在可以左右移动的车轮上。假设外力干扰引起小车产生角加速度 x(t)x(t) x(t)。沿着垂直于小车底盘方向进行受力分析，可以得到车体倾角与车轮运动加速度 a(t)a (t) a(t) 以及外力干扰加速度 x(t)x(t) x(t) 之间的运动方程： Image 3.3.1 - 小车运动方程 alt > 对应小车静止时，系统输入输出的传递函数为： H(s)=(Θ(sχ(s))=1s2−gL)\r H(s)= (\\frac {\\Theta (s}{\\chi(s)})=\\frac {1}{s^2-\\frac{g}{L}})\r H(s)=(​χ(s)​​Θ(s​​)=​s​2​​−​L​​g​​​​1​​) 此时系统具有两个极点： sp=±gL\r s_p=\\pm \\sqrt \\frac{g}{L}\r s​p​​=±√​​L​​g​​​​​ 我们可以根据传递函数 H(s)=(Θ(sχ(s))=1s2−gL)\r H(s)= (\\frac {\\Theta (s}{\\chi(s)})=\\frac {1}{s^2-\\frac{g}{L}})\r H(s)=(​χ(s)​​Θ(s​​)=​s​2​​−​L​​g​​​​1​​) ，调用 Matlab 软件，绘制出传递函数的根轨迹示意图，如下图所示。 通过根轨迹示意图，可以很清晰的看出两轮自平衡小车的传递函数对应有两个零极点，有一个在 s 平面的右半平面。这说明两轮自平衡小车是不稳定的。 小车引入比例、微分（PD）反馈之后的系统如下图所示： Image 3.3.2 - 加入比例微分反馈后的系统框图 alt > 系统传递函数为： H(s)=(Θ(sχ(s))=1s2+k2LS+k1−gL)\r H(s)= (\\frac {\\Theta (s}{\\chi(s)})=\\frac {1}{s^2+ \\frac {k_2}{L}S+ \\frac {k_1 -g}{L}})\r H(s)=(​χ(s)​​Θ(s​​)=​s​2​​+​L​​k​2​​​​S+​L​​k​1​​−g​​​​1​​) 此时两个系统极点位于： sp=(−k2±(K22−4l(K1−G))2L)\r s_p= (\\frac {-k_2 \\pm \\sqrt (K^2 _2 -4l(K_1-G))}{2L})\r s​p​​=(​2L​​−k​2​​±√​(​​​K​2​2​​−4l(K​1​​−G))​​) 系统稳定需要两个极点都位于 s 平面的左半平面。要满足这一点，需要k1>gk_1>gk​1​​>g，k2>0k_2>0k​2​​>0。 我们调用 Matlab 软件绘制当前系统传递函数的根轨迹图，并且求解极点值。如下图所示。 Image 3.3.3 - 两轮自平衡小车系统稳定时对应根轨迹极点 alt > 通过根轨迹图可以清晰地看出，此时系统传递函数的极点都已经分布在了 s 平面的左半平面，只要参数适合，极点的位置将会进一步远离 0 点，系统将会更稳定。 由此可以得出结论，当 k1>gk_1>gk​1​​>g，k2>0k_2>0k​2​​>0 时，两轮自平衡小车可以稳定。这与前面通过分析所得出的结论是一致的。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A44.html":{"url":"A44.html","title":"Simulink仿真","keywords":"","body":"Simulink仿真 通过对两轮自平衡小车系统进行动力学分析和数学建模，在理论上设计出了控制方法。下面，调用 Matlab 软件的 Simulink 仿真工具包对两轮自平衡小车的控制系统数学模型进行仿真验证，观察角度在干扰信号的作用下的自恢复情况。 在 Simulink 文件中，建立两轮自平衡小车的数学模型，调用 PID 控制器构成控制系统的主要部分。设定输入信号值为 0，代表角度初始值为 0，小车初始在平衡位置。对输出节点，调用两个 Step 模块，通过设定 Step Time，使之构成宽度为 1s 的脉冲信号作为小车的外力干扰作用信号。整体系统构成负反馈形式，如下图所示。 Image 3.4.1 - 两轮自平衡小车控制系统数学模型的 Simulink 仿真 alt > 仿真系统中示波器 Angle 与 f 分别表示角度变化波形与外力作用信号波形。点击运行，可以看到外力作用为标准的脉冲信号。如下图所示。 Image 3.4.2 - 外界干扰信号波形图 alt > 此时，在脉冲信号作为干扰的情况下，Angle 示波器中显示了车体角度的变化值。如下图所示。 Image 3.4.3 - 车体角度自恢复过程仿真波形 alt > 通过波形可以看出，角度在外界干扰的情况下，能够在一定时间内自动恢复到稳定状态。这证明了前文建立的两轮自平衡小车控制系统的数学模型是有效的，也为接下来设计小车的软硬件系统提供了坚实的控制理论基础。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"B22.html":{"url":"B22.html","title":"系统框架一览","keywords":"","body":"系统框架 本小节对硬件部分的系统框架进行说明。 Image 4.1.1 - 系统框架 由上面系统框架图可以看到，整个系统围绕 STM32F103C8T6 主芯片运行，电池经过降压稳压后提供稳定的 5v 和 3.3v 给 STM32 主芯片和各电子模块，STM32 主芯片通过读取 MPU-6050 传感器芯片的数据，获取小车系统的运动状态，再通过 TB6612FNG 驱动芯片控制直流电机的运动，直流电机通过编码器反馈转速给 STM32 主芯片，这就构成了两轮自平衡小车的基本硬件框架。其他的辅助功能，比如蓝牙、OLED、超声波、红外等等都是可加可不加的功能，我们为了提高两轮自平衡小车的可玩性和操纵性，一并加进去。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"B06.html":{"url":"B06.html","title":"主控模块","keywords":"","body":"主控接口 在「小霸王Lite」中，主控模块选择使用 MiaowLabs-STM32F1-Micro 核心板，板载 STM32F103C8T6 芯片。 主控芯片相当于人的大脑，接收并处理各传感器（包括陀螺仪和加速度传感器的信号），完成计算和规划后，向各执行机构（比如电机）发出控制命令。 MiaowLabs-STM32F1-Micro 核心板有以下特色： 板载 2 个 LED，1 个用户指示灯和 1 个电源指示灯，其中用户指示灯可以通过编程进行控制。 板载 2 个按键，1 个用户按键和 1 个复位按键，其中用户按键可以通过编程进行控制。 板载 USB-TTL 电路和 Micro-USB 接口，只需要一根数据线就能与上位机通信，也可以用作固件升级。 预留有 SWD 接口，可以外接调试器（比如 JLink-ob、ST-Link等）进行下载和调试。 主控芯片选择使用 STM32F103C8T6，因为它的体积小（LQFP48，7x7mm），功耗低（3.3V工作电压），运算速度快（10.25MIPS， ARM 32-bit Cortex™-M3 CPU），具有丰富的外设模块。它的主要外设包括但不限于： PWM： 8通道； AD转换器：10通道，12位； 定时器： 3通道16位通用定时器（TIM2/TIM3/TIM4），1通道高级控制定时器（TIM1）； 丰富的外部串行接口：SCI，I2C，SPI； IO口：最多可以提供 32 路，可以与 5V 器件直接相连。 内部存储器资源包括： 64k 程序 Flash， 20k 数据 RAM。 下图显示该单片机的内部资源情况。 Image 4.2.1 - 内部资源 在「小霸王Lite」中，STM32F103C8T6 芯片必须用到的的 IO 引脚有： I2C 通讯接口：读取 MPU-6050 数据 I2C1_SDA（PB8，PIN45）； I2C1_SCL（PB9，PIN46）； Timer正交解码接口：读取编码器的脉冲数据 TIM2_CH1（PA0）和TIM2_CH2（PA1）：TIM2定时器增量编码器输入； TIM4_CH1（PB6）和TIM4_CH2（PB7）：TIM4定时器增量编码器输入； 电机 PWM 驱动接口：控制电机转速 TIM3_CH1（PA6）和TIM3_CH2（PA7）：电机驱动； 电机转向驱动接口：控制电机转向 AIN1(PB0)、AIN2(PB1)、BIN1(PA3)、BIN2(PA4) 程序调试 SWD 接口 SWDIO（PIN34）； SWCLK（PIN37）； 串口下载 UART 接口 TXD（PIN6）； RXD（PIN7）； 蓝牙通讯 UART 接口 TXD（PIN33）； RXD（PIN34）； 除了以上确定使用的引脚，其它没有占用的引脚全部预留出来，并且在底板上用两排排针引出，用户可以非常方便地使用杜邦线连接其他模块进行扩展。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"B09.html":{"url":"B09.html","title":"稳压模块","keywords":"","body":"稳压接口 本小节对稳压接口进行说明。 在「小霸王Lite」中，动力来源为两节 18650 动力锂电池，每节电池额定电压 3.7v（充满电压 4.1v），两节电池串联得到的 7.4v（充满电压 8.2v）。但是，电路中常用的电压为 5v 和 3.3v，所以，我们并不能直接把电池电压供给电路模块，而是需要对 7.4v 进一步降压稳压，分别降压至 5v 和 3.3v，以供整个电路系统使用。 我们自制了一块降压稳压模块，板载 LM2940-5.0、LM1117-3.3 两款低压差线性稳压芯片（LDO），两者的最大输出电流分别为 1000mA、800mA，不俗的输出电流能够满足小车的正常工作，并且还能给后续的扩展预留了电流余量。另外，LM2940-5.0、LM1117-3.3 两款 LDO 芯片工作效率高、输出电压纹波比 DC/DC 芯片要小得多。 为了能实时监测输入电压的变化情况（即电池电压，电池电压表征电池容量），我们在稳压降压模块中加入一个电阻分压检测电路，使用 STM32 的 ADC 引脚采集到分压电阻的电压值，然后再进行转换运算，就能得到电池的电量状况，并在算法中调整参数对应电压的变化。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"B12.html":{"url":"B12.html","title":"驱动模块","keywords":"","body":"驱动接口 本小节对直流电机的结构、原理、实物接线方法，以及减速器的作用，并且说明了使用直流电机驱动芯片TB6612FNG控制直流电机的方法。 众所周知的是单片机的 IO 引脚的输出电流很小（推挽输出最多几百毫安），点亮个 LED 灯没问题，但是带不动电机。因此，我们无法直接使用单片机控制电机的转速和转向。为了能用单片机控制电机，常规的的办法是在两者之间加一个电机驱动电路，由单片机通过控制电机驱动电路来驱动电机。 在「小霸王Lite」两轮自平衡小车中，我们使用电机驱动芯片 TB6612FNG 来进行控制电机。 电路原理图如下图所示： Image 4.4.1 - 驱动芯片 TB6612FNG 是东芝半导体公司生产的一款直流电机驱动器件，具有大电流 MOSFET-H 桥结构，双通道电流输出，可以同时驱动两个电机。因为两轮自平衡小车刚好也是只有两个电机，所以只要用一块 TB6612FNG 就够了。也许大家更熟悉的是L298N，其实这两者的使用大同小异。相比 L298N 的热耗性和外围二极管续流电流，TB6612FNG 能承受的负载电流更大，而且不用外加散热片，外围电路比较简单，只需外接电源滤波电容就可以直接驱动电机，因此，电机驱动模块可以设计得很小巧。 TB6612FNG 电机驱动芯片的主要特性： 驱动电压：最大支持15V 输出电流：1.2A（连续）/ 3.2A（峰值） 工作模式：支持正转/反转/刹车/停止四种模式 封装尺寸：SSOP24，0.65mm引脚间距 TB6612FNG 内部集成两组 H 桥驱动电路，所以能直接驱动两个直流电机。TB6612FNG 内部框图如下图所示。 Image 4.4.2 - TB6612FNG 内部框图 接线方式 TB6612FNG 的规格书其实已经给出了经典的接线方式。 Image 4.4.3 - 接线方式 我们在实际的应用中，应该怎么接线呢？下面我们就 TTM2 电机给出对应的接线示意图，其他电机也可以参考。 Image 4.4.4 - 测试方法 其中，VM 直接接电池即可。VCC 是内部的逻辑供电，给 5v 就行。模块的 3 个 GND 接任意一个即可，因为内部都是导通的。另外，STBY 要接 5v，模块才能正常工作。 完成上面的接线之后，我们就可以开始控制电机了，上图中红框部分的 5 个引脚控制 1 路电机，蓝框部分的控制另外 1 路电机，这里讲的两路的使用方法是一样的。AO1 和 AO2 分别别到电机的 + 和 -，然后通过 PWMA、AIN1、AIN2 控制电机。其中，PWMA 接到单片机的 PWM 引脚，一般 10Khz 的 PWM 即可，并通过改变占空比来调节电机的速度。AIN1、AIN2 两个引脚一般接单片机的 GPIO 引脚，用来控制电机的正反转，下面是真值表： AIN1 0 1 0 AIN2 0 0 1 转动方式 停止 正转 反转 测试方法 我们可以通过简单的方法来使用 TB6612FNG 测试电机转动： 按照以下方式接线： VM 直接接电池正极（注意：电压 当 AIN1 接 5v、AIN2 接 GND、PWMA接 5v，这样相当于控制电机满占空比正转； 当 AIN1 接 GND、AIN2 接 5v、PWMA 接 5v，这样相当于控制电机满占空比反转。 电机实物接线图 具体到我们的电机，我们可以看看电机后面的图解。 Image 4.4.5 - 电机实物接线图 你可以会产生疑问：直流电机不是只有两根电机线吗？怎么这个电机有 6 根线？而且还有两个大焊点？其实，根据上面的图解也知道，那两个大焊点分别与两边的两根线是连接在一起的。也就是说这 6 根线，中间的 4 根线是编码器的线，只是用于测速，和直流电机本身没有联系。我们在进行开环控制的时候无需使用。 综上所述，我们只需要控制施加在电机线两端的直流电压大小和极性即可实现控制转速和方向。 直流电机的结构 直流电动机的基本构造包括“电枢”、“场磁铁”、“集电环”、“电刷”。 电枢：可以绕轴心转动的软铁芯缠绕多圈线圈。 场磁铁：产生磁场的强力永久磁铁或电磁铁。 集电环：线圈约两端接至两片半圆形的集电环，随线圈转动，可供改变电流方向的变向器。每转动半圈（180度），线圈上的电流方向就改变一次。 电刷：通常使用碳制成，集电环接触固定位置的电刷，用以接至电源。 直流电机的原理 此为一个简单的直流电（D.C.）电动机。当线圈通电后，转子周围产生磁场，转子的左侧被推离左侧的磁铁，并被吸引到右侧，从而产生转动。 转子依靠惯性继续转动。 当转子运行至水平位置时电流变换器将线圈的电流方向逆转，线圈所产生的磁场亦同时逆转，使这一过程得以重复。 减速器 减速器，又称减速箱，通常应用在低转速大扭矩的传动设备，把原电机高速运转的动力（每分钟几千上万转），通过减速器输入轴上的齿数少的齿轮啮合输出轴上齿轮大的齿轮，来达到减速的目的。大小齿轮的齿数之比就是传动比。减速器在执行机构之间起匹配转速和传递转矩的作用，是一种相对精密的机械，使用它的目的是降低转速和增加转矩。 减速器种类繁多，按传动和结构特点划分，减速器种类有齿轮减速器（Gear reducer）、蜗杆减速器（Worm wheel reducer）、蜗杆齿轮减速器及齿轮-蜗杆减速器、行星齿轮减速器(Planetary gears)、摆线针轮减速器（Cycloid reducer）和谐波齿轮减速器(Harmonic drive)等。 齿轮减速器体积较小，传递扭矩大，但是有一定的回程间隙。 蜗杆减速器的主要特点是具有反向自锁功能，可以有较大的减速比，但是一般体积较大，传动效率不高，精度不高。 行星减速器的主要特点是结构紧凑，回程间隙小、精度较高，使用寿命很长，额定输出扭矩可以做得很大，但价格昂贵。 下面是TTM1直流减速电机——一款搭配齿轮减速器的电机。 黄色部分为减速箱，减速箱与电机直接联接，电机上的电路板为编码器。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A20.html":{"url":"A20.html","title":"蓝牙模块","keywords":"","body":"通信接口 本小节对通信接口进行说明。 我们在底板上预留了 3 种通信接口： 蓝牙无线接口 nRF24L01 2.4G 无线接口 ESP8266 Wifi 无线接口 我们暂时只编写了蓝牙通信部分的代码。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"B23.html":{"url":"B23.html","title":"传感器模块","keywords":"","body":"传感器接口 本小节对传感器接口进行说明。 在「小霸王Lite」两轮自平衡小车中，我们使用了一款六轴传感器 MPU-6050 模块来获取车体的运动姿态。 Image 4.6.1 - MPU-6050 模块 MPU-6050 MPU-6050 是 InvenSense 公司推出的全球首款整合性 6 轴运动处理组件，相较于多组件方案，免除了组合陀螺仪与加速器时之轴间差的问题，有效减少了安装空间。 MPU-6050 内部整合了 3 轴陀螺仪和 3 轴加速度传感器，并且含有一个 IIC 从接口，可用于连接外部磁力传感器，并利用自带的数字运动处理器（DMP: Digital Motion Processor）硬件加速引擎，通过 IIC 主接口，向应用端输出完整的 9 轴融合演算数据。有了DMP，我们可以使用 InvenSense 公司提供的运动处理资料库，非常方便的实现姿态解算，降低了运动处理运算对操作系统的负荷，同时大大降低了开发难度。 Image 4.6.2 - MPU-6050 MPU-6050 的主要特点： 以数字形式输出 6 轴或 9 轴（需外接磁传感器）的旋转矩阵、四元数(quaternion)、欧 拉角格式(Euler Angle forma)的融合演算数据（需 DMP 支持） 具有 131 LSBs/° /sec 敏感度与全格感测范围为 ±250、±500、±1000 与 ±2000° /sec 的 3 轴角速度感测器(陀螺仪) 集成可程序控制，范围为 ±2g、±4g、±8g 和 ±16g 的 3 轴加速度传感器 移除加速器与陀螺仪轴间敏感度，降低设定给予的影响与感测器的飘移 自带数字运动处理(DMP: Digital Motion Processing)引擎可减少 MCU 复杂的融合演算 数据、感测器同步化、姿势感应等的负荷 内建运作时间偏差与磁力感测器校正演算技术，免除了客户须另外进行校正的需求 自带一个数字温度传感器 带数字输入同步引脚(Sync pin)支持视频电子影相稳定技术与 GPS 可程序控制的中断(interrupt)，支持姿势识别、摇摄、画面放大缩小、滚动、快速下降 中断、 high-G 中断、零动作感应、触击感应、摇动感应功能 VDD 供电电压为 2.5V± 5%、 3.0V± 5%、 3.3V± 5%； VLOGIC 可低至 1.8V± 5% 陀螺仪工作电流： 5mA，陀螺仪待机电流： 5uA；加速器工作电流： 500uA，加速器省 电模式电流： 40uA@10Hz 自带 1024 字节 FIFO，有助于降低系统功耗 高达 400Khz 的 IIC 通信接口 超小封装尺寸： 4x4x0.9mm（ QFN） MPU-6050 的内部框图： Image 4.6.3 - MPU-6050 内部框图 其中， SCL 和 SDA 连接 MCU 的 IIC 主接口， MCU 通过这个 IIC 接口来控制 MPU-6050， 另外还有一个 IIC 从接口： AUX_CL 和 AUX_DA，这个接口可用来连接外部从设备，比如磁传感 器，这样就可以组成一个九轴传感器。 VLOGIC 是 IO 口电压，该引脚最低可以到 1.8v，我们 一般直接接 VDD 即可。 AD0 是从 IIC 接口（接 MCU）的地址控制引脚，该引脚控制 IIC 地址 的最低位。如果接 GND，则 MPU6050 的 IIC 地址是： 0X68，如果接 VDD，则是 0X69，注意： 这里的地址是不包含数据传输的最低位的（最低位用来表示读写）！！ MPU-6050 模块上， AD0 默认是接 GND 的，所以此时 MPU-6050 的 IIC 地址是 0X68（不含最低位）。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"B25.html":{"url":"B25.html","title":"底板功能说明","keywords":"","body":"底板功能说明 功能参考《系统框架一览》小节。 Image 4.7.1 - PCB Top Layer View console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"B26.html":{"url":"B26.html","title":"电机参数说明","keywords":"","body":"电机参数说明 电机作为两轮自平衡小车的重要组成部件，在这里有必要对电机参数进行说明。 两轮自平衡小车要进行速度控制，就必须用上速度闭环。要构成速度闭环，必须使用带有编码器的直流减速电机。「小霸王Lite」两轮自平衡小车使用了定制的直流减速电机，转速快、扭矩大。 实物照片 Image 4.8.1 - 带霍尔编码器直流减速电机TTM1 alt > 具体参数 型号：MW-TTM1 减速比：1:48 额定电压：6V（承受范围3~9V） 空载转速(6v)：260rpm 空载电流(6v)：350mA 堵转电流(6V)：1.5A 堵转扭矩(6V)：2.5kgf.cm 额定扭矩(6V)：1.5kgf.cm 编码器电压：2.5~12V 编码器线数：384线（即电机黄色减速箱的输出轴转一圈，我们单测A相或B相得到 384 个脉冲；AB相都测量能得到 384 × 2 个脉冲；四倍频则测量到 384 × 4 个脉冲） 编码器相数：AB相（相位差 90°） 操作环境温度：-10~+60℃ 重量：50g 购买链接 淘宝：MW-TTM1 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"B24.html":{"url":"B24.html","title":"洞洞板底板手工焊接教程","keywords":"","body":"洞洞板底板手工焊接教程 本小节教你如何焊接洞洞板底板。需要有一定的焊接基础，比如会使用烙铁，并且焊点饱满不虚焊。 对于毕设党、课设党、参赛党而言，虽然原来的底板可以直接使用，但是毕竟不是自己亲手焊接出来的，会缺少一点成就感。如果能自己动手焊接一块底板，不仅拥有爆棚的成就感，而且通过毕设、课设，甚至获奖的概率会大大提高。在焊接过程中，你不但能锻炼焊接能力，而且能进一步加深对小车系统电路的理解，在答辩的过程中可以理直气壮地回答问题。 手工焊接存在一定的难度，要有优良的焊接能力。如果是第一次进行焊接，我建议多备份一套物料，在焊坏第一套物料损坏之后，可以使用第二套物料焊接。每个人的焊接水平都不一样，有的人可能一次过焊接成功，有的人焊坏几块板都不一定成功。但是只要坚持练习焊接，随着焊接水平的提高，总会成功。本教程仅作为指引，不保证一定成功。 准备工具 电烙铁 焊锡 镊子 焊接过程 知晓预设的X轴Y轴方向。这个方向是我们自己定义的，为了方便和保证我们后面的焊接行动是统一的。 我们以洞洞板左上方为原点，坐标定义为（1,1），向下为 Y 轴正方向，向右为 X 轴正方向。将原点坐标定义为 (1,1)，而不是 (0,0)，是对应洞洞板四周的原标号。后面我们通过数孔位，就可以确定排母插座的摆放位置。为了提高焊接成功率，请务必按照我们的位置摆放。如下图所示， Image 4.9.1 - 定义X轴Y轴方向以及摆放位置 alt > 我们从上往下，逐步逐个焊接。 焊接排母 第一步，在坐标 (18~21,1) 四个孔位焊接一个 4Pin 单排母。这里的 X 轴坐标 18~21，表示 18、19、20、21 四个点，后面的表达同理。在焊接时，可以先焊接一个引脚作为定位，然后观察排母是否焊接到位，摆放是否垂直。如果不垂直，则可以加热定位引脚，纠正错误，直至没问题，再焊接其他引脚。后面焊接排母和插座都可以先焊接定位引脚，观察没问题，再焊接其他引脚，不再重复强调。 第二步，在坐标(12~28,5)，共 17 个孔位焊接一个 17Pin 单排母。 第三步，在坐标(12~28,12)，共17个孔位焊接另一个 17Pin 单排母。与第二步的 17Pin 排母一起组成底座，用于放置核心板。 第四步，在坐标(10~13,15)，共 4 个孔位焊接一个 4Pin 单排母。该排母用于放置蓝牙模块。 第五步，在进行第五步之前，先跳到第十五步安装支撑柱，然后把 MPU-6050 模块插到排母上，用螺丝固定模块在支撑柱上，再进行焊接排母引脚，这样可以最大程度把 MPU-6050 模块的排母焊正。MPU-6050 模块焊歪，会影响姿态数据输出。在坐标(16,16~23)，共 8 个孔位焊接一个 8Pin 单排母。该排母用于放置 MPU-6050 模块。 第六步，在坐标(23,16~23)，共 8 个孔位焊接一个 8Pin 单排母。 第七步，在坐标(29,16~23)，共 8 个孔位焊接一个 8Pin 单排母。与第六步的排母一起组成底座，用于放置 TB6612FNG 驱动模块。 第八步，在坐标(15,26~29)，共 4 个孔位焊接一个 4Pin 单排母。 第九步，在坐标(29,26~29)，共 4 个孔位焊接一个 4Pin 单排母。与第八步的排母一起组成底座，用于放置稳压模块。 第十步，在坐标(17~22,33)，共 6 个孔位焊接一个 6Pin 单排母。该排母用于放置 OLED 显示模块。 焊接插座 第十一步，在坐标(1,2~7)，共 6 个孔位焊接一个 XH2.54-6P 直插插座，插座缺口朝向 X 轴正方向。 第十二步，在坐标(4,25~30)，共 6 个孔位焊接一个 XH2.54-6P 直插插座，插座缺口朝向 X 轴负方向。 第十三步，在坐标(35,25~30)，共 6 个孔位焊接一个 XH2.54-6P 直插插座，插座缺口朝向 X 轴正方向。 焊接开关 第十四步，在坐标 (38,30~34)，共 5 个孔位焊接拨动开关。 安装支撑柱 第十五步，在坐标(20~21,22~23)，共 1 个 M3 螺丝孔安装白色支撑柱。该支撑柱用于固定 MPU-6050 模块，支撑柱与排母形成三角形，可以很好地固定模块。 至此，顶层的排母、插座、开关已经焊接完毕。接下来，开始焊接底层的走线。 焊接走线 Image 4.9.2 - 还没焊接电池盒的走线参考图 alt > 我们在顶层数孔位，在底层焊接。在翻转洞洞板后，左右顺序是对调的，要注意并反复核对引脚顺序，再进行焊接。 第十六步，延续上面的步骤，到这里是第十六步。因为每个模块都要接地，所以地线的线路最多、最复杂。其他信号线相比之下显得十分简单。因此我们先从最难的下手，先焊接地线。这里把焊接地线分成 12 小步： 超声波模块和核心板的地线相连，从坐标(18,1)，飞一根线连接坐标 (12,12)。 核心板和红外模块的地线相连，从坐标 (12,12) 飞一根线连接坐标 (1,6)。 核心板和蓝牙模块的地线相连，从坐标(12,12)飞一根线连接坐标(11,15)。 蓝牙模块和 MPU-6050 模块的地线相连，从坐标(11,15)飞一根线连接坐标(16,17)。 MPU-6050 模块和 TB6612FNG 驱动模块的地线相连，从坐标(16,17) 飞一根线连接坐标(29,21)。 TB6621FNG 驱动模块和稳压模块的地线相连，从坐标(29,21)飞一根线连接坐标(29,29)。 稳压模块与右电机编码器的地线相连，从坐标(29,29)飞一根线连接坐标(35,29)。 稳压模块的输入地线和输出地线相连，从坐标(29,29)飞一根线连接坐标(15,26)。 稳压模块的输出地线与左电机相连，从坐标(15,26)飞一根线连接坐标(4,26)。 稳压模块的输入地线和 OLED 显示模块的地线相连，从坐标(29,29)飞一根线连接坐标(17,34)。 稳压模块的输入地线和电池负极相连，从(29,29)飞一根线连接坐标(25,32)。 地线的焊接到这里暂停一下。等到后面焊接电池盒，我们再从坐标(25,32)飞一根线到电池盒负极焊接，才最终完成地线的全部焊接。焊接到这里，只要焊接没差错，所有的地线都应该是连通的。我们拿万用表，推到二极管档，以稳压模块的输入地线坐标(29,29)为参考点，把其他焊点全部测一遍导通与否。 第十七步，焊接电池正极输入线路。电池盒和拨动开关连接，从坐标(14,32)飞一根线连接坐标(38,32)。等到后面焊接电池盒，再从坐标(14,32)飞一根线连接电池盒正极，我们把这根线留到最后再焊接。拨动开关和稳压模块连接，从坐标(38,33)飞一根线连接坐标(29,26)。因为电机是直接由电池供电，所以电池正极线路也需要连接 TB6612FNG。我们已经从拨动开关连接到稳压模块，遵循就近原则飞线，稳压模块和 TB6612FNG 驱动模块连接，从坐标(29,26)飞一根线连接坐标(29,23)。焊接到这里，电池正极输入线路已焊接完成。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况。 第十八步，焊接 5V 电源线。稳压模块输出 5V 与TB6612FNG 相连，从坐标(15,29)飞一根线连接坐标(29,22)，再从坐标(29,22)飞一根线连接坐标(23,20)。连接超声波模块，从坐标(23,20)飞一根线连接坐标(21,1)。连接红外模块插座，从坐标(21,1)飞一根线连接坐标(1,7)。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况，并且测试 5V 电源线跟地线是否有短路连通现象。如果有连通，那么就要检查哪里短路了。 第十九步，焊接 3.3V 电源线。稳压模块输出 3.3V 与 OLED显示模块相连，从坐标(15,28)飞一根线连接坐标(33,21)。连接右边电机编码器，从坐标(33,21)飞一根线连接坐标(35,26)，连接左边电机编码器，从坐标(15,28)飞一根线连接坐标(4,29)。连接 MPU-6050 模块，从坐标(15,28)飞一根线连接坐标(16,16)。连接超声波模块，从坐标(16,16)飞一根线连接坐标(10,15)。连接核心板，从坐标(16,16)飞一根线连接坐标(13,5)。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况。并且测试 3.3V 电源线跟地线是否有短路连通现象。如果有连通，那么就要检查哪里短路了。 到这里，连线最多最复杂的几个线路：地线、电池正极输入、5V 电源线、3.3V 电源线都已经焊接完成，剩下的线路都相对简单了。 第二十步，焊接核心板和 MPU-6050 模块的信号线。SCL 线，从坐标(13,12)飞一根线连接坐标(16,18)。SDA 线，从坐标(14,12)飞一根线连接(16,19)。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况。 第二十一步，焊接核心板和 TB6612FNG 驱动模块的信号线。PWMB 线，从坐标(24,12)飞一根线连接坐标(23,17)。BIN2 线，从坐标(21,12)飞一根线连接坐标(23,18)。BIN1 线，从坐标(20,12)飞一根线连接坐标(23,19)。AIN1 线，从坐标(25,12)飞一根线连接坐标(23,21)。AIN2 线，从坐标(26,12)飞一根线连接坐标(23,22)。PWMA 线，从坐标(23,12)飞一根线连接坐标(23,23)。其中，PWMA、PWMB 是连接核心板 PWM 引脚，控制电机速度；AIN1、AIN2、BIN1、BIN2 是连接核心板 GPIO 引脚，控制电机转向。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况。 第二十二步，焊接 TB6612FNG 和电机接口的输出引脚。BO1 线，从坐标(29,17)飞一根线连接坐标(35,30)。BO2 线，从坐标(29,18)飞一根线连接坐标(35,25)。AO2 线，从坐标(29,19)飞一根线连接坐标(4,25)。AO1 线，从坐标(29,20)飞一根线连接坐标(4,30)。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况。 第二十三步，焊接核心板和编码器的信号线。左电机 A 相，从坐标(17,12)飞一根线连接坐标(4,27)。左电机 B 相，从坐标(18,12)飞一根线连接坐标(4,28)。右电机 A 相，从坐标(15,5)飞一根线连接坐标(35,28)。右电机 B 相，从坐标(14,5)飞一根线连接坐标(35,27)。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况。 第二十四步，焊接核心板和蓝牙模块的信号线。Rx 线，从坐标(27,12)飞一根线连接坐标(13,15)。Tx 线，从坐标(28,12)飞一根线连接坐标(12,15)。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况。 第二十五步，焊接核心板和超声波模块的信号线。Echo 线，从坐标(19,1)飞一根线连接坐标(21,5)。Trig 线，从坐标(20,1)飞一根线连接坐标(19,12)。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况。 第二十六步，焊接核心板和红外模块插座的信号线。Rb 线，从坐标(24,5)飞一根线连接坐标(1,2)。Ra 线，从坐标(19,5)飞一根线连接坐标(1,3)。Lb 线，从坐标(18,5)飞一根线连接坐标(1,4)。La 线，从坐标(16,5)飞一根线连接坐标(1,5)。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况。 第二十七步，焊接核心板和 OLED 显示模块的信号线。SCL 线，从坐标(25,5)飞一根线连接坐标(19,34)。SDA 线，从坐标(26,5)飞一根线连接坐标(20,34)。RST 线，从坐标(27,5)飞一根线连接坐标(21,34)。DC 线，从坐标(15,12)飞一根线连接坐标(22,34)。为了保证焊接质量，我们要拿万用表测量每两个焊点之间的通断情况。 第二十八步，焊接电池盒。电池盒的两个电池槽之间是没有电气连接的，电池盒可以根据使用方式（并联/串联）自行进行电气连接。在这里，我们是将两节电池串联使用，即两个电池槽要进行串联的电气连接。从坐标(14,3)飞一根线到坐标(25,3)，从底层走飞线。然后接下来的四根线注意在顶层飞线： 在坐标(14,3)单点焊接一根飞线出来，预留 10mm 长度，另一端暂时悬空，等下和电池盒引脚一起焊接。 在坐标(25,3)单点焊接一根飞线出来，预留 10mm 长度，另一端暂时悬空，等下和电池盒引脚一起焊接。 在坐标(25,32)，这个焊点在第十六步就已经焊接，单点焊接一根飞线出来，预留 10mm 长度，另一端暂时悬空，等下和电池盒引脚一起焊接。 在坐标(14,32)，这个焊点在第十七步就已经焊接，单点焊接一根飞线出来，预留 10mm 长度，另一端暂时悬空，等下和电池盒引脚一起焊接。 焊接电池盒。因为电池盒本身没有电气连接，所以对放置方向没有规定，你转动 180 度焊接也可以。将电池盒放置好，将上面预留的四根飞线分别就近焊接在电池盒引脚上。坐标(14,3)飞线连接电池盒引脚(15~16,3~4)，坐标(25,3)飞线连接电池盒引脚(23~24,3~4)，坐标(25,32)连接电池盒引脚(23~24,32~33)，坐标(14,32)连接电池盒引脚(15~16,32~33)。 焊接完成。 Image 4.9.3 - 洞洞板焊接完成图 alt > console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"F03.html":{"url":"F03.html","title":"约定代码编写规则","keywords":"","body":"代码编写规则 本小节制定一些编写代码时使用的规则，以便大家达成共识，沟通顺畅。 为了增强代码的可读性，方便萌新们之间相互交流代码，我们有必要先约定一些规则： 使用匈牙利命名法 保持函数名称简短 匈牙利命名法 萌新们在编写代码时，通常喜欢简单地使用 i、j、k 来命名，可能不是太妥当，别人理解的时候，脑袋里面要运行着一个很深的堆栈。理解和遵循一定的变量命名规范，使得程序代码具有“自明”特性，编写程序就可以减少注释的工作，从而可以避免混淆。 匈牙利命名法（Hungarian notation）是计算机程序设计中的一种变量命名规则，由1972年至1981年在施乐帕洛阿尔托研究中心工作的程序员查尔斯·西蒙尼（Charles Simonyi）发明。此人后来成了微软的总设计师。 匈牙利命名法的基本原则是： 变量名 = 属性 + 类型 + 对象描述 其中每一对象的名称都要求有明确含义，可以取对象名字全称或名字的一部分。要基于容易记忆容易理解的原则。 比如， g_fGyroscopeAngleSpeed 其中，g_ 表示表示全局变量，没有该前缀是局部变量。全局变量在头文件中进行定义，在程序初始化函数中都进行初始化。小写字母 f 代表变量类型float，而 GyroscopeAngleSpeed 为变量名称，表示变量的含义——陀螺仪测量的角速度。可以看出，匈牙利命名法非常便于记忆，而且使变量名非常清晰易懂，增强了代码的可读性，方便各程序员之间相互交流代码。 变量属性： 全局变量：g_ 常量：c_ 静态变量：s_ x 轴：x_ y 轴: y_ z 轴：z_ 类型部分： float：f double float：df int：i unsigned int：i short int：n long int：l char：c 描述部分： 最大　Max 最小　Min 初始化　Init 临时变量　T（或Temp） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A07.html":{"url":"A07.html","title":"安装MDK-ARM软件","keywords":"","body":"安装 MDK-ARM 软件 安装 MDK-ARM 软件 没学过 STM32 等 ARM 单片机的同学可能对 MDK-ARM 感到陌生，但提起 Keil，学过 51 单片机的同学就再熟悉不过了。Keil 公司被 Arm 公司收购后，推出了 MDK-ARM。MDK-ARM 是一个针对 Arm 芯片（不能编译51、avr等），集代码编辑，编译，链接和下载于一体的集成开发环境（IDE）。在我们学习编写代码之前需要先要把 MDK-ARM 软件安装好，本节示例用的版本是 V5.17。在安装完成之后，可以在工具栏 help->about uVision 选项卡中查看到版本信息。 在目录 光盘\\07.开发环境及烧录工具\\MDK517.exe 找到 MDK517.exe，双击 MDK517.exe，在弹出 MDK 安装界面后，按照如下步骤操作即可。 点击 Next。 把勾勾上，同意使用协议，点击 Next。 接下来就是设置安装路径，注意路径名一定不能含有中文。在安装时可以不更改路径，直接安装在 C 盘。我个人习惯将这些非系统必需软件都是安装在 D 盘 Program Files (x86)文件目录下，在本节示例中，选择路径时我就直接把 C 盘改为 D 盘就可以了，后面的路径都使用默认路径。路径选择好继续 Next。 在用户名中填入名字（可随便写，你喜欢就好），在邮件地址那里填入邮件地址（可随便写，你喜欢就好），点击 Next。 开始自动安装，请耐心等待。 点击 Finish，安装完成。 （二）安装 Pack 包 打开 MDK-ARM 后会自动弹出 Pack Installer 界面。程序会自动去 Keil 的官网下载各种支持包，但是由于 Keil 的服务器可能在国外，在下载支持包过程时快时慢，甚至会以失败告终，遇到这种失败情况，我们可以直接点击OK，然后关闭支持包安装器，自己到Keil官网下载自己需要的支持包，下载地址为http://www.keil.com/dd2/pack 。 打开上面的下载地址，然后选择我们使用的芯片型号，本示例要下载 STM32F1 系列的Pack。在页面中 “Ctrl+F”打开搜索栏输入关键词 “STM32F1” ,可以快速定位到我们想要下载的内容。 点击下载图标，会弹出一个许可，我们点击 “Accept”，就会开始下载。 下载完，就得到我们想要的 “Keil.STM32F1xx_DFP.2.2.0.pack”。 双击 pack 文件，打开 pack 的 安装界面，会自动识别 MDK 的安装路径。 点击 “Next” 后，进入自动安装环节，耐心等待片刻。 点击“Finish”，安装结束。 这样就完成了 STM32F1 系列 Pack 的安装。如果需要下载其他 Pack，方法是一样的，只是选择不同的 Pack 安装包。 到此，MDK517已安装完成，可以看到桌面上有Keil uVision5的快捷方式图标。 和谐 MDK 以管理员身份运行 Keil uVision5 图标。注意，直接双击无法和谐，请右键选择“以管理员身份运行”。 打开 Keil uVision5 后，点击： File目录下的 License Management，调出注册管理界面，可以发现我们这个版本是 “Evaluation Version”，即试用版，只可以免费使用180天，而且不能编译超过2K的代码。 进行破解。破解过程很简单，先对电脑进行禁音操作，因为破解软件 keygen 会发出奇妙的声音。把 keygen.exe 剪贴到 MDK5 目录下（要先解压，如果杀毒软件误报误杀，那就先关了杀毒软件，再解压），在 keygen.exe 里面，设置 Target为 ARM，然后拷贝 MDK License Management 界面里面的 CID 号，到 keygen.exe 里面 CID 栏，点击： Generate，即可获得注册码。 获取注册码之后，拷贝注册码到 Keil uVision5 的 License Management 里面，点击 Add LIC 即可完成注册 。从图中可以看到，我们破解后 MDK5，不再是试用的专业版，显示可以用到 2020 年了，这个 2020 年只是一个日期，实测就算过了这个日期也可以使用，毕竟已经和谐了。 至此，MDK 已成功进行和谐，没有编译代码限制。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A02.html":{"url":"A02.html","title":"使用MDK-ARM软件编译代码","keywords":"","body":"编译代码 本小节以光盘里的工程为例，对工程代码进行编译。 本节需要提前安装 MDK-ARM 软件。 打开工程。在光盘/02.源代码/Mwbalanced-stm32-小霸王Lite-firmware-互补滤波-none V3.3/BasicBalance.uvprojx 找到 BasicBalance.uvprojx 工程文件，然后双击打开工程。 工程打开后，在 MDK-ARM 界面中，可以看到左上方的工具栏中有三个按钮（如下图红圈位置所示）。 Image 5.3.1 - A02 现在，从左往右依次介绍这三个按钮的功能。 第一个按钮：Translate 是编译当下修改过的文件，说明白点就是检查下有没有语法错误，但不会去链接库文件，也不会生成可执行文件。 第二个按钮：Build 是编译当下修改过的文件，它包含了语法检查，链接动态库文件，生成可执行文件。 第三个按钮：Rebuild 是重新编译整个工程，跟 Build 这个按钮实现的功能是一样的，但不同的是 Rebuild 编译的是整个工程的所有文件，耗时巨大。 俗话说，时间就是金钱，效率就是生命。在我们编写程序的过程中，使用得比较多的是第二个按钮： Build 按钮，只编译当下修改过的文件，比使用 Rebuild 按钮的全部文件重新编译一次能节省很多时间，而且一样能重新生成可执行文件。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A08.html":{"url":"A08.html","title":"安装STM32CubeMX软件","keywords":"","body":"安装 STM32CubeMX 软件 本小节详细介绍如何安装和使用 STM32CubeMX 软件。 STM32CubeMX 软件是 STM32 ARM Cortex-M 微控制器的图形配置和底层代码生成工具。近年来，STMicroelectronics 公司一直大力推广 HAL + STM32CubeMX 的开发方式，STM32CubeMX 软件可以通过图形化向导可以快速、轻松配置 STM32 系列单片机的底层驱动，并生成相应的初始化 C 代码。从此，我们不需要像建立各种文件夹、复制各种各样的库文件才能新建一个工程。当你熟悉使用 STM32CubeMX 软件后，你不会想回滚使用以前的老旧的新建工程方法。 相关链接 STM32CubeMX 官方网站下载地址： 官方网站 在相关链接中的官网地址可以下载最新版本的 STM32CubeMx。截至2020年4月5日，最新版本为 5.6.0 具体步骤 下载软件。上面内容已给出的相关链接，可以从 ST 官方网站下载最新版本的 STM32CubeMx，或者可以直接使用光盘里面的安装包进行安装，STM32CubeMx 版本号为 5.6.0。 在目录 光盘\\07.开发环境及烧录工具\\en.stm32cubemx 找到en.stm32cubemx.zip 压缩包，进行解压，得到 SetupSTM32CubeMX-4.27.0.exe 可执行文件，双击文件进行安装。 进入安装界面，点击 “Next”。 选择 “I accept ...” 接受使用协议，点击 “Next”。 选择安装路径。默认路径安装也行。我习惯安装将系统无关软件安装到D盘，所以示例中将 C 盘改成 D 盘，其他不变。点击 “Next”。 选择在开始菜单创建快速图标，和在桌面创建快捷方式。直接默认，点击“Next”。 进入自动安装环节，稍等片刻就能完成。待安装完成后，点击 “Next”。 Image 5.4.1 - 完成安装 alt > 安装成功，提示 “Installation has completed successfully”。点击 “Done”，退出安装界面。 导入固件库 安装完 STM32CubeMX 软件后，我们还要下载对应的固件库（Package）。但是由于众所周知的原因，我们国内的网络有时候很难下载国外的资源，在下载的过程中容易出错导致下载失败。为此，我们在资料包中预先帮大家下载好了 Package ，导入使用即可。我们的例程使用的固件库版本为 STM32Cube_FW_F1_V1.7.0，全部例程都已经测试通过。ST 官方可能会不断更新固件库，但是目前 STM32Cube_FW_F1_V1.7.0 是比较稳定的版本，其他新版本暂时不作使用，以免出现奇怪的 bug，比如按键在 STM32Cube_FW_F1_V1.7.0 测试通过，在 STM32Cube_FW_F1_V1.8.0 会出现无法使用的情况。 按照下面的步骤，就可以导入固件库。 点击“Help”下拉项，然后双击“Manage embedded software packeges”。 Image 5.4.2 - 在Help栏目中选中导入固件包 接着，点击“From Local”，选择光盘/07、开发工具安装包/stm32cube_fw_f1_v170.zip，再点击打开，就会自动导入。 Image 5.4.3 - 选中对应固件包，然后自动导入 alt > 选择固件库 在打开工程后，在工程设置里面把“Use Default Firmware Location”前面的勾√取消掉，手动选择 STM32Cube_FW_F1_V1.7.0。 Image 5.4.4 - 手动选中 STM32Cube_FW_F1_V1.7.0 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A21.html":{"url":"A21.html","title":"STM32CubeMX软件生成工程","keywords":"","body":"STM32CubeMX 软件生成工程 本小节以 MiaowLabs-STM32F1-Micro 控制板为例，教你使用 STM32CubeMX 软件生成工程，然后使用 MDK-ARM 5.17 软件编译工程。 例程代码基于 STM32Cube FW_F1 V1.7.0。 开始配置 打开 STM32CubeMX 软件，点击「ACCESS TO MCU SELECTOR」。 选择芯片 点击「ACCESS TO MCU SELECTOR」之后，进入选择芯片型号界面。 MiaowLabs-STM32F1-Micro 控制板上的 MCU 型号为 STM32F103C8T6，因此我们要找到 STM32F103C8T6 芯片，有两种方法： 第一种：搜索框大法。在 Part Number Search 搜索框中输入我们用到的芯片型号，本例中输入「STM32F103」。右边的 MCUs List 就会显示相关型号，能够轻易地找到 STM32F103C8T6 型号。 第二种：按图索骥法。在左边选择下拉列表慢慢筛选，直至筛选出想要的芯片： 根据 Core（内核）选择。如：ARM Cortex-M3... 根据 Series（系列）选择。如：F0、F1、F2... 根据 Line（产品线）选择。 根据 Package（封装）选择。 等等，不一一展开说明。 经过搜索或筛选，看到 STM32F103C8T6 芯片型号，双击选择芯片。 工程配置 双击选择芯片后，就会进入芯片的工程配置界面。 点击 Project Manager，切换到工程设置界面，并对工程设置进行基本设置。 其中，工程名称为 MiaowLabs-Demo，工程目录存放在电脑桌面，IDE 工具选择 MDK-ARM V5，其他默认，点击 OK 即可。如果提示工程路径 d 盘不存在，那么修改路径中的 d 为 D 即可，大小写是有区别的。 默认情况下，STM32cubeMX 软件会把不生成主函数的选勾给打上，我们要把选勾去掉。 本小节的目的只是演示一遍如何新建工程，所以，我们暂时不配置芯片的引脚。我们点击右上方的 GENERATE CODE，生成代码。 生成代码进度条结束后，会弹出提示框。 点击 Open Folder，会打开工程的文件夹；点击 Open Project，会直接打开 MDK 工程；点击 Close，则不进行任何操作，并关闭该对话框。 我们点击 Close ，关闭该对话框，回到电脑桌面，会发现工程文件夹已经创建好了，我们打开该文件夹可以看到一些文件夹和文件。 其中，Drivers 文件夹存放 HAL 库的底层驱动文件，Inc 存放配置头文件，Scr 存放配置源文件，MDK-ARM 存放 MDK-ARM 工程文件，MiaowLabs-Demo.ioc 是 STM32CubeMX 的工程文件。 我们进入 MDK-ARM 文件夹，会看到一些文件夹和 MDK-ARM 工程文件。其中，MiaowLabs-Demo.uvprojx 是 MDK-ARM 工程文件。 双击 MiaowLabs-Demo.uvprojx，MDK-ARM 软件自动运行并打开该工程。 我们对打开的工程进行编译，发现没有提示错误。 到这里，我们的工程已经新建成功，是不是觉得其实很简单？接下来的章节，我会继续教你深入使用 STM32CubeMX 配置 STM32 的引脚功能，让我们放轻松，一步一个脚印，稳步前行，你会发现在不知不觉中就已经掌握了制作两轮自平衡小车的基础知识。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A11.html":{"url":"A11.html","title":"GPIO与LED闪烁的仪式感","keywords":"","body":"GPIO 和 LED 闪烁的仪式感 本小节教你使用 STM32CubeMX 软件配置 MiaowLabs-STM32F1-Micro 控制板的底层驱动，并使用 MDK-ARM 5.17 编写代码点亮板子上的的蓝色 LED。 在上一小节中，我只是教你使用 STM32CubeMX 软件生成工程，但没有进行任何实际应用操作。在这一小节，我将教你在生成工程的基础上，继续配置 GPIO 引脚点亮 LED 灯，然后编写代码使其闪烁起来。 跟学习编程语言时编写 Hello World 程序一样，在学习单片机时编写点灯程序也是一个充满仪式感的学习过程。点灯程序编写成功，意味着 MCU 初始化、语言环境、编译连接烧写复位、硬件供电都基本正确了，其他的操作就都有了基础。 预先了解 MiaowLabs-STM32F1-Micro 控制板上面有一颗用户灯（蓝色 LED） 是跟 STM32 的 PB12 引脚相连。我们可以通过编程控制该 LED 的亮灭状态，当 PB12 引脚为低电平时，LED 为亮状态；当 PB12 引脚为高电平时，LED 为灭状态。 Image 5.6.1 - LED 原理图 具体步骤 进入我们上一小节创建的 MiaowLabs-Demo 文件夹，找到 MiaowLabs-Demo.ioc 工程文件，双击，打开工程。在 Pinout&Configuration 界面中的芯片中点击 PB12，并将其配置为 GPIO_Output。 在左侧的 System Core 下拉菜单中选择 SYS，然后在 SYS Mode and Configuration 中把 Debug 设置成 JTAG(4 pins)，即是把系统配置和模式设置为 JTAG 接口，方便我们后面使用 SWD 调试工具。 在左侧的 System Core 下拉菜单中选择 RCC，然后在 RCC Mode and Configuration 中把 High Speed Clock (HSE) 和 Low Speed Clock (LSE) 设置为 Crystal/ceramic Resonator，即是把高速、低速时钟源都设置成外部晶振。 在左侧的 System Core 下拉菜单中选择 GPIO，然后在 GPIO Mode and Configuration 中对 PB12 引脚进行配置，GPIO output level 代表 GPIO 默认输出电平，在这里设置为低电平；GPIO mode 代表 GPIO 引脚模式，在这里设置为推挽输出；GPIO Pull-up/Pull-down 即 GPIO 上拉或下拉，在这里设置为既不上拉也不下拉；Maximum output speed 即 最大输出速度，在这里设置为高速；User Label 即用户标签，因为 PB12 在这里的功能是用作控制 LED，所以输入 LED 作为标签。 点击 Clock Configuration，配置时钟，在 HCLK(MHz) 中输入 72，然后按一下键盘的 Ener 回车键。这样，就可以自动把时钟配置到 72 MHz。 点击 GENERATE CODE，重新生成代码。 使用 MDK-ARM 打开工程代码，重新编译代码，编译完成后，提示没有错误。 然后可以在 MiaowLabs-Demo、MDK-ARM\\MiaowLabs-Demo 文件夹中找到 MiaowLabs-Demo.hex 文件，将其烧录进核心板，可以发现核心板上的用户灯（蓝色 LED）已经亮起来了啦。 但是，这离我们的小目标——让 LED 闪烁起来还有一点小差距，不过已经很接近了。 我们回到 MDK-ARM 工程代码中，在左侧 Project 栏目的 Application/User 文件夹中找到 main.c 文件，双击，打开。接着，找到 int main(void) 主函数，在主循环 while(1) 中加入以下代码： HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);//翻转LED引脚（PB12）的电平 HAL_Delay(500);//等待500ms，即0.5s HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);//翻转LED引脚（PB12）的电平 HAL_Delay(500);//等待500ms，即0.5s 这段代码的意思，就是在主循环中，先翻转一次 PB12 引脚电平，然后保持 0.5s，再翻转一次 PB12 引脚电平，保持 0.5s，并且不断重复以上步骤，显示出来的效果就是 LED 一秒钟闪烁一次。 我们在加入代码的时候，注意一定要把代码加在 UER CODE BEGIN xx 和 USER CODE END xx 之间，因为这是 STM32CubeMX 预留给用户添加代码的地方。不然，在下次我们点击 GERATER CODE 重新生成代码后，STM32CubeMX 会抹去我们添加的代码。 到这里，我们就实现了控制 LED 闪烁的目标。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A22.html":{"url":"A22.html","title":"Timer与按键消抖的应用","keywords":"","body":"Timer 与按键消抖的应用 本小节教你使用 STM32CubeMX 软件配置 MiaowLabs-STM32F1-Micro 核心板按键引脚的底层驱动，并使用 MDK-ARM 5.17 编写代码识别用户按键的单击动作，实现使用按键控制 LED 的亮灭功能。 在上一小节中，我们使用 STM32CubeMX 软件配置 MiaowLabs-STM32F1-Micro 核心板的底层驱动，并使用 MDK-ARM 5.17 编写代码点亮板子上的的蓝色 LED。在这一小节，我将继续教你实现使用按键控制 LED 的亮灭功能。 预先了解 MiaowLabs-STM32F1-Micro 核心板板上面有一颗用户按钮 是跟 STM32 的 PA11 引脚相连。我们可以通过编写代码识别按键的单击，当 PA11 引脚为低电平时，识别为按下按键；当 PA11 引脚为高电平时，识别为按下按键。 注意：自 2020年 08月 01日起，两轮自平衡小车「小霸王Lite」的 STM32 核心板已经升级，与旧版核心板相比，两个地方有改动：一是板载两颗按键 User1、User2，分别连接 PA8、PB3（旧版核心板只有一颗按键，连接 PA11）；二是添加了串口一键下载电路。本节教程原为旧版核心板配套教程，配置上使用 PA11，为了方便新旧客户查阅，暂时不做大的修改，使用新核心板的客户，请参考下面操作步骤，用 PA8 替代 PA11 的配置，即下面原配置 PA11 的步骤全部改成 配置 PA8，实现按键 User1 控制 LED 的亮灭。User2 暂时预留备用，不作配置。后面还有《电机速度闭环内环PID控制》也用到按键，其他章节则没有改动，全部兼容新核心板。 具体步骤 进入我们上一小节修改过的 MiaowLabs-Demo 文件夹，找到 MiaowLabs-Demo.ioc 工程文件，双击，打开工程。在 Pinout&Configuration 界面中的芯片中点击 PA11，并将其配置为 GPIO_Input。 在左侧的 System Core 下拉菜单中选择 GPIO，然后在 GPIO Mode and Configuration 中对 PA11 引脚进行配置，GPIO mode 代表 GPIO 引脚模式，在这里设置为输入模式；GPIO Pull-up/Pull-down 即 GPIO 上拉或下拉，根据硬件实际情况，在这里设置为上拉；User Label 即用户标签，因为 PA11 在这里的功能是识别按键，所以输入 Button 作为标签。 点击 GENERATE CODE，重新生成代码。 因为通常的按键所用开关为机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上稳定地接通，在断开时也不会一下子断开。因而在闭合及断开的瞬间均伴随有一连串的抖动，为了不产生这种现象而作的措施就是按键消抖。 消抖是为了避免在按键按下或是抬起时电平剧烈抖动带来的影响。按键的消抖，可用硬件或软件两种方法，在实际的设计中，为了节省硬件成本，大多数情况会选择使用软件消抖。 延时消抖 软件消抖，即检测出按键闭合后执行一个延时程序，5ms～10ms 的延时，让前沿抖动消失后再一次检测键的状态，如果仍保持闭合状态电平，则确认为真正有键按下。当检测到按键释放后，也要给 5ms～10ms 的延时，待后沿抖动消失后才能转入该键的处理程序。 以前常用的消抖算法往往就是：判断按下->延时->再次判断是否按下->是，执行/否，退出。 最简单的消抖原理，就是当检测到按键状态变化后，先等待一个 10ms 左右的延时时间，让抖动消失后再进行一次按键状态检测，如果与刚才检测到的状态相同，就可以确认按键已经稳定的动作了。 //按键处理函数 void ButtonScan(void) { static int ButtonFlag = 0;//按键标志,1代表松开，0代表按下 if(Button == 0)//第一次判断按键按下 { delay_ms(10);//延时10ms，去抖动 if(Button == 0)//第二次判断按键按下 { ButtonFlag = 1; //确认按键为按下，按键标志置1 } } 利用定时器消抖 利用定时器消抖算法：通过 SysTick 中断每1ms对按键进行扫描，当检测到连续的稳定无抖动电平信号（长度可设置）之后，才进行相应的逻辑操作。 我们启用一个定时中断，每 1ms 进一次中断，扫描一次按键状态并且存储起来，连续扫描 25 次后，看看这连续 25 次的按键状态是否是一致的。25 次按键的时间是 25ms，这 25ms 内如果按键状态一直保持一致，那就可以确定现在按键处于稳定的阶段，而非处于抖动的阶段。 我们在上一小节中已经对 SYS 进行了配置。 在 STM32CubeMX 中，默认 SysTick 中断为 1ms。 我们可以打开 MDK-ARM 工程，在左侧 Drivers/STM32F1xx_HAL_Driver 文件夹的 stm32f1xx_hal.c 文件中找到 SysTick 的初始化。 /** * @brief This function configures the source of the time base. * The time source is configured to have 1ms time base with a dedicated * Tick interrupt priority. * @note This function is called automatically at the beginning of program after * reset by HAL_Init() or at any time when clock is reconfigured by HAL_RCC_ClockConfig(). * @note In the default implementation, SysTick timer is the source of time base. * It is used to generate interrupts at regular time intervals. * Care must be taken if HAL_Delay() is called from a peripheral ISR process, * The SysTick interrupt must have higher priority (numerically lower) * than the peripheral interrupt. Otherwise the caller ISR process will be blocked. * The function is declared as __weak to be overwritten in case of other * implementation in user file. * @param TickPriority Tick interrupt priority. * @retval HAL status */ __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority) { /* Configure the SysTick to have interrupt in 1ms time basis*/ if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U) { return HAL_ERROR; } /* Configure the SysTick IRQ priority */ if (TickPriority 函数里面有一句注释： /* Configure the SysTick to have interrupt in 1ms time basis*/，翻译过来就是，将 SysTick 配置为 1ms 中断。也就是说，经过此函数，SysTick 定时器被初始化为 1ms 的时基单元，即每毫秒进入一次 Systick 中断。 我们可以在左侧 Application/User 文件夹的 stm32f1xx_it.c 文件中找到 SysTick 中断服务函数。 /** * @brief This function handles System tick timer. */ void SysTick_Handler(void) { /* USER CODE BEGIN SysTick_IRQn 0 */ /* USER CODE END SysTick_IRQn 0 */ HAL_IncTick(); /* USER CODE BEGIN SysTick_IRQn 1 */ /* USER CODE END SysTick_IRQn 1 */ } 里面只有一个 HAL_IncTick() 函数，我们右键转跳到该函数可以看到该函数的定义。 /** * @brief This function is called to increment a global variable \"uwTick\" * used as application time base. * @note In the default implementation, this variable is incremented each 1ms * in SysTick ISR. * @note This function is declared as __weak to be overwritten in case of other * implementations in user file. * @retval None */ __weak void HAL_IncTick(void) { uwTick += uwTickFreq; } 每毫秒 uwTick 加一，用于计算 Systick 产生的节拍数。 在 HAL_IncTick 函数的下方有一个 HAL_GetTick(void) 函数，主要用于获取当前节拍，如果内核正常运行，则 uwTick 的值即为已经经过的 ms 数。 这里顺便提及一下 HAL 库的延时函数 HAL_Delay() 。在左侧 Drivers/STM32F1xx_HAL_Driver 文件夹的 stm32f1xx_hal.c 文件中找到 HAL_Delay() 函数。 /** * @brief This function provides minimum delay (in milliseconds) based * on variable incremented. * @note In the default implementation , SysTick timer is the source of time base. * It is used to generate interrupts at regular time intervals where uwTick * is incremented. * @note This function is declared as __weak to be overwritten in case of other * implementations in user file. * @param Delay specifies the delay time length, in milliseconds. * @retval None */ __weak void HAL_Delay(uint32_t Delay) { uint32_t tickstart = HAL_GetTick(); uint32_t wait = Delay; /* Add a freq to guarantee minimum wait */ if (wait 可以看到 HAL_Delay() 函数其实就是通过 HAL_GetTick() 函数数节拍以确定精准的延时。 回到按键消抖的主题，既然 STM32CubeMX 已经默认设置 Systick 为 1ms 中断，那么我们可以直接利用起来。打开 MDK-ARM 工程，按下组合键 Ctrl+N（按住 Ctrl 键再按 N 键），新建一个文件，再按下组合键 Ctrl+S，文件名改为 button.c，保存到 MiaowLabs-DEMO 的 Src 文件夹里。来到这里，我们虽然新建了button.c 源文件，但是还没有把该文件加入到 MDK-ARM 工程里。我们在 MDK-ARM 工程界面左侧 Project 栏目双击 Application/User 文件夹，把 button.c 加进来。 双击 button.c 文件，把下面代码敲进去。 #include \"button.h\" #include \"main.h\" #include \"stm32f1xx_it.h\" int iButtonCount;//i代表int型变量，ButtonCount表示按键计数变量 int iButtonFlag;//i代表int型变量，ButtonFlag表示重按键标志，1代表重新按键，0为没有重新按键 int g_iButtonState;//g是globle代表全局变量，会在其他地方引用；i代表int型变量，ButtonState表示按键标志，1代表按下，0代表松开 void ButtonScan(void){ if( HAL_GPIO_ReadPin(Button_GPIO_Port,Button_Pin) == GPIO_PIN_RESET )//如果引脚检测到低电平 { iButtonCount++; //按键按下，计数iButtonCount加1 if(iButtonCount>=30) //1ms中断服务函数里运行一次，iButtonCount大于等于30，即按键已稳定按下30ms { if(iButtonFlag==0) //判断有没有重按键，1为有，0为没有 { g_iButtonState=1; //设置按键标志 iButtonCount=0; iButtonFlag=1; //设置重按键标志 } else //如果重按键，则重新计数 iButtonCount=0; } else //如果没有稳定按下30ms，则代表没有按下按键 g_iButtonState=0; } else //如果一直无检测到低电平，即一直无按键按下 { iButtonCount=0; //清零iButtonCount g_iButtonState=0; //清除按键标志 iButtonFlag=0; //清除重按键标志 } } 再新建一个文件 button.h 头文件，把文件保存到 Inc 文件夹。然后，把下面代码敲进去。 #ifndef __BUTTON_H #define __BUTTON_H extern int g_iButtonState;//声明外部变量，方便其他地方引用 void ButtonScan(void);//声明按键扫描函数 #endif 打开 stm32fxx_it.c 文件，在 /* USER CODE BEGIN Includes */ 与 /* USER CODE END Includes */ 之间加入 #include \"button.h\"。 在 stm32fxx_it.c 文件里面 SysTick_Handler() 函数里加入按键扫描函数 ButtonScan()。 在左侧 Application/User 文件夹里打开 main.c 函数，在主循环里面加入以下代码： if(g_iButtonState == 1){ HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);//翻转LED引脚（PB12）的电平 } 这段代码的意思就是：如果按键状态标志为 1 ，则代表按键被按下了，这时候进行 LED 电平翻转。 在左侧 Application/User 文件夹里点开 main.c 函数左侧的加号，找到 main.h 头文件，并把#include \"button.h\"头文件加进去。 代码已经编写好了。这时候，点击编译按钮，会提示没有错误和警告。 把代码烧录进 MiaowLabs-STM32F1-Micro 核心板，然后按下用户按键，可以发现按一下 LED 会亮，再按一下 LED 就会灭掉。就这样，我们实现了通过按键控制 LED 亮灭的功能。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A23.html":{"url":"A23.html","title":"Usart与Printf函数重定向","keywords":"","body":"Usart与Printf函数重定向 本小节教你使用 STM32CubeMX 软件配置 MiaowLabs-STM32F1-Micro 核心板的 Usart1 的底层驱动，并使用 MDK-ARM 5.17 编写代码对 Printf 函数进行重定向，实现使用 Printf 函数通过 Usart1 发送数据到上位机的功能。 预先了解 Image 5.8.1 - CP2102 电路原理图 MiaowLabs-STM32F1-Micro 核心板板载 CP2102 USB to TTL 芯片，该芯片连接 STM32F103C8T6 芯片的 Usart1 引脚。 具体步骤 进入我们上一小节修改过的 MiaowLabs-Demo 文件夹，找到 MiaowLabs-Demo.ioc 工程文件，双击，打开工程。在左侧 Pinout&Configuration 界面中的 Connectivity 下拉中点击 USART1，然后在 USART1 Mode and Configuration 的 Mode 中选择 Asynchronous。Asynchronous 为异步通信的意思。Parameter Setting（基础设置）为默认设置，其中波特率为 115200 Bits/s，字节长度为 8 Bits。 Image 5.8.2 - USART1 基础设置 点击 NVIC Setting，对 USART1 global interrupt 的选择框打钩，启用 USART1 的全局中断。 Image 5.8.3 - 启用 USART1 全局中断 在 Project Manager 的 Code Generator 中勾选 generate periheral initialization as apair of “.c/.h” files per periheral，可以让每个外设都生成一个文件，不用全部都堆在 Main.c 文件中。我们的前两个实验都只是配置 GPIO 外设，所以没勾选该选项也没问题。但是，现在我们的外设用到了 Usart，在使用较多外设的情况下，应该勾选该选项。 Image 5.8.4 - 选项打钩 点击 GENERATE CODE，重新生成代码。 Image 5.8.5 - 重新生成代码 打开 MDK-ARM 工程，你会发现在左侧栏的 Application/User 文件夹中多了 gpio.c 和 usart.c 文件，这是因为我们刚才勾选了 generate periheral initialization as apair of “.c/.h” files per periheral，STM32CubeMX 会把我们用到的外设都单独生成一个文件（在这里我们只用到了 GPIO 和 USART），方便我们另行修改。而且，你在 Main 函数中会发现多了初始化函数 MX_USART1_UART_Init()，即 USART1 的初始化函数。 Image 5.8.6 - USART1 初始化函数 在实际项目中通常使用串口打印调试信息进行 Debug，调试 STM32 的时候，需要标准库里面的 printf函数。我们使用 STM32CubeMX 生成工程，HAL_USART_Transmit 函数即是工程里串口输出的函数。由于printf 最终是调用 fputc 输出数据，而 fputc 是一个 weak（弱引用）函数，覆写即可重定向 printf。 注意，在 MDK-ARM 工程里要把 USE MicroLIB 选上。 Image 5.8.7 - 选择 USE MicroLIB 打开 usart.c，在 /* USER CODE BEGIN 0 */ 和 /* USER CODE END 0 */ 把标准输入输入头文件 stdio.h 加进去，并且加入以下代码： #ifdef __GNUC__ /* With GCC/RAISONANCE, small printf (option LD Linker->Libraries->Small printf set to 'Yes') calls __io_putchar() */ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif /* __GNUC__ */ Image 5.8.8 - 代码截图 在 /* USER CODE BEGIN 1 */ 和 /* USER CODE END 1 */ 之间加入以下代码： /** * @brief Retargets the C library printf function to the USART. * @param None * @retval None */ PUTCHAR_PROTOTYPE { /* Place your implementation of fputc here */ /* e.g. write a character to the EVAL_COM1 and Loop until the end of transmission */ HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF); return ch; } Image 5.8.9 - 代码截图 到这步，就搞掂了 printf 函数的重定向。接下来，就是我们如何使用 printf 函数的问题了。 在主函数 main 里面的主循环中加入以下代码： if(g_iButtonState == 1){ HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);//翻转LED引脚（PB12）的电平 printf(\"LED GPIO TOGGLE! \\n\");//打印一次 LED GPIO TOGGLE! 文字出来 } 这段代码的意思是，我们按一下用户按键，控制 LED 亮灭，同时每按一次按钮，都会打印 LED GPIO TOGGLE! 这段话出来。 代码已经编写好了。这时候，点击编译按钮，会提示没有错误和警告。 先把代码烧录进 MiaowLabs-STM32F1-Micro 核心板，接着，用数据线接上 MiaowLabs-STM32F1-Micro 核心板，然后打开喵呜地面站（曾用名：喵呜多功能调试助手）或其他任意串口助手，设置波特率为 115200 ，校验位为无校验，停止位为 1 位，选择文本模式，点击打开串口，这时每按一下用户按键，都能看到打印出 LED GPIO TOGGLE!。 Image 5.8.10 - 打印出 LED GPIO TOGGLE! console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A24.html":{"url":"A24.html","title":"Timer编码器模式读取编码器","keywords":"","body":"定时器编码器模式读取脉冲数据 本小节教你使用 STM32CubeMX 配置定时器的编码器模式，读取电机编码器的脉冲数据，并且利用 Printf 函数把数据发送到电脑端上位机显示出来。 预先了解 Image 5.9.1 - 电机接口电路原理图 通过上面的电机接口电路原理图可以看到，「小霸王Lite」两轮自平衡小车使用两个通用定时器（TIM2、TIM4）分别捕获两个电机上的编码器的脉冲数据。 STM32F10x 系列 MCU 的所有通用定时器及高级定时器都集成了编码器接口。定时器的两个输入 TI1 和 TI2 分别与增量式编码器的 A 相、B 相相接。当定时器设为编码器模式时，这两个信号的边沿作为计数器的时钟。在这个模式下，计数器依照增量编码器的速度和方向被自动地修改。 具体步骤 接下来，我们以通用定时器 TIM4 配置编码器模式为例，进行具体的讲解。定时器 TIM4 的正交模式与 TIM2 的配置过程是一样的。 进入我们上一小节修改过的 MiaowLabs-Demo 文件夹，找到 MiaowLabs-Demo.ioc 工程文件，双击，打开工程。在左侧 Pinout&Configuration 界面中的 Timers 下拉中点击 TIM4，然后在 TIM4 Mode and Configuration 的 Mode 中将 Combined Channels 选择为 Encoder Mode，即编码器模式。 Image 5.9.2 - 将 Combined Channels 选择为 Encoder Mode 在 Configuration 中选择 Parameter Setting 选项卡，进行基本参数配置。其中，Counter Mode 默认为 Up，即向上计数。Counter Period 设置为 65535，即计数器周期，这是一个 16 位的自动加载寄存器，填写范围为 0~65535。Encoder Mode 设置为 Encoder Mode TI1 and TI2，即两个输入 TI1 和 TI2 都被用来作为增量编码器的接口。Polarity 默认为 Rising Edge，即为捕获上升沿。其他参数默认即可。 值得注意的是，Encoder Mode 设置为 Encoder Mode TI1 and TI2 模式时，AB 两相的上升沿和下降沿都会计数，所以计数值是实际脉冲值的 4 倍，即四倍频。Channel1 和 Channel2 的 Polarity 参数默认是 Rising Edge，意思是在检测到上升沿的时候就触发编码器模式接口捕获 AB 相的值，并不是指只检测 AB 相的上升沿，下降沿还是同样会计数的。 Image 5.9.3 - Parameter Settings 选项卡的参数配置 点击 GENERATE CODE，重新生成代码。 Image 5.9.4 - 重新生成代码 打开 MDK-ARM 工程，左侧 Application/User 里多个 tim.c 源文件，而且在 main 函数里可以看到多出一个 TIM4 初始化函数： MX_TIM4_Init();。 Image 5.9.5 - 代码截图 打开 MDK-ARM 工程，按下组合键 Ctrl+N（按住 Ctrl 键再按 N 键），新建一个文件，再按下组合键 Ctrl+S，文件名改为 encoder.c，保存到 MiaowLabs-DEMO 的 Src 文件夹里，接着在 MDK-ARM 工程界面左侧 Project 栏目双击 Application/User 文件夹，把 encoder.c 加进来。 Image 5.9.6 - 代码截图 双击 encoder.c 文件，把下面代码敲进去。（尽可能手动敲一遍） #include \"tim.h\"//包含tim头文件 #include \"encoder.h\" int iTim4Encoder;//存放从TIM4定时器读出来的编码器脉冲 int GetTim4Encoder(void)//获取TIM4定时器读出来的编码器脉冲 { iTim4Encoder = (short)(__HAL_TIM_GET_COUNTER(&htim4));//先读取脉冲数 __HAL_TIM_SET_COUNTER(&htim4,0);//再计数器清零 return iTim4Encoder;//返回脉冲数 ｝ Image 5.9.7 - 代码截图 再新建一个文件 encoder.h 头文件，把文件保存到 Inc 文件夹。然后，把下面代码敲进去。 #ifndef __ENCODER_H #define __ENCODER_H int GetTim4Encoder(void);//声明函数 #endif 打开 main.c 文件，在 main 函数中的 /* USER CODE BEGIN 1 */ 和 /* USER CODE END 1 */ 之间定义一个变量： int iTempTim4Encoder; //临时存放从TIM4编码器接口捕获到的脉冲数据 Image 5.9.8 - 代码截图 在主循环里，把以下代码敲进去： HAL_Delay(5000);//延时5秒 iTempTim4Encoder = GetTim4Encoder();//捕获TIM4脉冲数据 printf(\"TIM4定时器编码器模式捕获脉冲 = %d \\n\",iTempTim4Encoder);//把脉冲数据打印出来 HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);//翻转指示灯LED的电平 上面这段加入主循环的代码的意思，是 TIM4 定时器的编码器捕获脉冲，每隔 5 秒累计输出一次脉冲数据，通过串口显示在上位机上。 这里补充一个知识点：M 法测速，就是数固定时间内产生的脉冲数，像这里每隔 5 秒数一次累计起来的脉冲数据，就是用了 M 法测速。 代码还没写完，有一句重要的代码必须要加进去，TIM4 的编码器接口模式才会启用。我们在 main 函数的 /* USER CODE BEGIN 2 */ 和 /* USER CODE END 2 */ 之间加入： HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);//开启TIM4的编码器接口模式 然后在 MDK-ARM 中重新编译代码，把代码烧录进 MiaowLabs-STM32F1-Micro 核心板，将核心板插到「小霸王Lite」两轮自平衡小车底板上，将整辆小车组装好，并用数据线连接核心板和电脑，打开喵呜地面站或其他串口助手软件，我们用手转动 TIM4 对应的电机轮子，就能够看到小车每隔 5 秒就将脉冲数据发送上去。 Image 5.9.9 - 串口助手截图 我们上面提到，得到的数据是四倍频的数据，「小霸王Lite」上用的电机单相单圈脉冲为 384 个脉冲，四倍频后，即 384 x 4 = 1536 个脉冲。可以从上面看到，当我们用手转动轮子半圈时，得到了 768 个脉冲，当然，我们用手转动轮子是无法精准地转动到理想位置（比如无法精确地转动半圈），会有偏差，但我们只要得到个大概的数据，判断能否正常读取编码器数据就可以了。 Image 5.9.10 - 串口助手截图 反应快的好奇宝宝在这里可能会提问：在上面的代码中，并没有对数值进行正负判断赋值，脉冲值怎么会出现负数？ 如果 TI1 和 TI2 分别接电机的 A 相和 B 相的话，那么，当电机正转的时候，如下图计数器会向上计数，反转的时候会向下计数，但是向下计数并不会出现负的值，依旧是从（0-ARR）计数。 Image 5.9.11 - 计数方向与编码器信号的关系 但是为什么出现一个负数呢？计数器的技术范围明明是 0～ARR。让我们回头看获取编码器脉冲的代码： int GetTim4Encoder(void)//获取TIM4定时器读出来的编码器脉冲 { iTim4Encoder = (short)(__HAL_TIM_GET_COUNTER(&htim4));//先读取脉冲数 __HAL_TIM_SET_COUNTER(&htim4,0);//再计数器清零 return iTim4Encoder;//返回脉冲数 ｝ 注意看，上面的代码 iTim4Encoder = (short)(__HAL_TIM_GET_COUNTER(&htim4)); 使用了强制类型装换，把寄存器的值读出来了之后，转换成了 short 型（2 字节），范围为（-32768-32767），此时当我们把计数器的初始值设置为 0 之后，如果出现反转，它就会从 0 开始向下计数（0,65535,65534，...）但是经过强制类型转换之后就变成了（0，-1，-2，...）。 有些好奇宝宝可能不明白，为什么 65535 会变成 -1 ？此时我们回到 short 的表示范围（-32768-32767），也就是说原来 int 型变量当读出来的值为 32767, 32768, 32769，...，65535，65536，65537... 的时候会因为强制转换成 short 型变量而溢出转换为 32767，-32768，-32767，...，-1，0，1 就这样不断地循环下去。所以电机反转的时候读出的数就是反方向的速度值，不需要用 65535 去减去读出的值再加上负号才可以得到方便观察的值，我们只需要巧妙地运用一个强制类型转换就可以了。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A25.html":{"url":"A25.html","title":"PWM与TB6612FNG驱动电机","keywords":"","body":"PWM与TB6612FNG驱动电机 本小节教你使用 STM32CubeMX 配置 PWM，并通过控制 TB6612FNG 电机驱动芯片驱动电机的转速和方向。 预先了解 STM32 与 TB6612FNG 的主要接线： PB0 --> AIN1 PB1 --> AIN2 PA3 --> BIN1 PA4 --> BIN2 TIM3_CH1 --> PWMA TIM3_CH2 --> PWMB TB6612FNG 电机驱动芯片，内置双 H 桥，可以驱动两个直流电机。其中，PWMA、AIN1、AIN2 为一组控制引脚，PWMA 为 PWM 速度控制引脚，AIN1、AIN2 为方向控制引脚；PWMB、BIN1、BIN2 为一组控制引脚，PWMB 为 PWM 速度控制引脚，BIN1、BIN2 为方向控制引脚。 具体步骤 在上一小节中，我们配置定时器 TIM4 的编码器接口模式，在转动电机时能读取小车右侧电机编码器的脉冲数据。接下来，我们以配置右侧电机的相关控制引脚（TIM3_CH2、PA3、PA4）为例，进行具体的说明。 驱动电机的 PWM 频率一般用 10kHz（0.0001ms），而且 TIM3 定时器是挂在 PAB1 时钟上，所以系统时钟 TIMx_CNT = 72MHz = 72000000Hz，设置 TIMx_PSC = 72，那么 TIMx_ARR = (TIMx_CNT/TIMx_PSC)* 0.1ms = (72000000/72)*0.0001 = 100。 进入我们上一小节修改过的 MiaowLabs-Demo 文件夹，找到 MiaowLabs-Demo.ioc 工程文件，双击，打开工程。在左侧 Pinout&Configuration 界面中的 Timers 下拉中点击 TIM3，然后在 TIM3 Mode and Configuration 的 Mode 中将 Channel2 选择为 PWM Generation CH2，并在下方的参数设置选项卡中将 Prescaler 设为 72，即预分频系数（TIMx_PSC）设为 72；Counter Period 设为 100，即计数周期（自动加载值 TIMx_ARR）设为 100；Pulse 设为 100，即占空比设置为 100%。 Image 5.10.1 - Parameter Settings 选项卡的参数配置 点击 GENERATE CODE，重新生成代码。 Image 5.10.2 - 重新生成代码 打开 MDK-ARM 工程，左侧 Application/User main.c 源文件的 main 函数里可以看到多出一个 TIM3 初始化函数： MX_TIM3_Init();。 Image 5.10.3 - 代码截图 TIM3_CH2 引脚生成 PWM 的底层驱动就配置好了，等 GPIO 也配置好再一起用。 回到 STM32CubeMX 软件界面，在右侧界面的芯片中分别点击 PA3、PA4，并将其配置为 GPIO_Output。在 System Core 下拉菜单中选择 GPIO，然后在左侧的 System Core 下拉菜单中选择 GPIO，然后在 GPIO Mode and Configuration 中对 PA3、PA4 引脚进行配置，GPIO output level 代表 GPIO 默认输出电平，在这里设置为低电平；GPIO mode 代表 GPIO 引脚模式，在这里设置为推挽输出；GPIO Pull-up/Pull-down 即 GPIO 上拉或下拉，在这里设置为既不上拉也不下拉；Maximum output speed 即 最大输出速度，在这里设置为低速；User Label 即用户标签，在这里将 PA3 改为 BIN1，PA4 改为 BIN2。 Image 5.10.4 - 配置 PA3、PA4 引脚 点击 GENERATE CODE，重新生成代码。 Image 5.10.5 - 重新生成代码 打开 MDK-ARM 工程，左侧 Application/User 里找到 gpio.c 源文件，双击打开，可以看到 MX_GPIO_Init() 函数里面已经有 BIN1_Pin|BIN2_Pin 的相关初始化代码。 Image 5.10.6 - 代码截图 在 main.c 中的 /* USER CODE BEGIN 2 */ 和 /* USER CODE END 2 */ 之间加入以下代码： /* USER CODE BEGIN 2 */ HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_2);//开启TIM3_CH2的PWM输出 HAL_GPIO_WritePin(BIN1_GPIO_Port, BIN1_Pin, GPIO_PIN_SET);//初始化BIN1引脚为低电平 HAL_GPIO_WritePin(BIN2_GPIO_Port, BIN2_Pin, GPIO_PIN_RESET);//初始化BIN2引脚为高电平 /* USER CODE END 2 */ Image 5.10.7 - 代码截图 然后，在主循环中加入以下代码： if(g_iButtonState == 1)//如果按键被按下 { HAL_GPIO_TogglePin(BIN1_GPIO_Port,BIN1_Pin);//翻转BIN1引脚电平，如果是低电平则翻转为高电平，如果是高电平则翻转为低电平 HAL_GPIO_TogglePin(BIN2_GPIO_Port,BIN2_Pin);//翻转BIN2引脚电平，如果是低电平则翻转为高电平，如果是高电平则翻转为低电平 g_iButtonState = 0;//按键状态归0，代表松开 } 上面这段代码的意思是，每次按下按键，左侧电机的转动方向都会更换一次，默认是全速转动（占空比 100%）。 代码已经编写好了。这时候，在 MDK-ARM 中点击编译按钮，会提示有一个警告（Warning），这是因为在上个实验中，我们定义了一个变量，但是在这次实验中没有使用。我们可以注释或者删除这个变量。 Image 5.10.8 - 编译后提示有一个警告 然后再重新编译一次，发现已经没有任何错误或者警告提示。 Image 5.10.9 - 编译后没有提示任何错误和警告 把代码烧录进小车中的 MiaowLabs-STM32F1-Micro 核心板，然后打开底板上的电源开关，小车的左侧电机全速转动，当我们按下用户按键，可以发现每按一下，电机的转向都会改变。就这样，我们实现了通过 TB6612FNG 驱动芯片，使用按键控制电机转向的功能。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A26.html":{"url":"A26.html","title":"硬件I2C读取MPU6050原始数据","keywords":"","body":"硬件I2C读取MPU6050原始数据 本小节教你使用 STM32CubeMX 配置 STM32 的 硬件 I2C，并通过 I2C 读取 MPU-6050 传感器的陀螺仪、加速度计数据。 预先了解 通过上面原理图得知，「小霸王Lite」两轮自平衡小车通过 STM32 的 I2C1 接口与 MPU-6050 传感器进行通信。我们这里使用的是轮询模式，只需要配置 PB8：I2C1_SCL、PB9：I2C1_SDA。如果使用中断模式，则还要使用一个 GPIO 引脚连接 MPU-6050 模块的 INT 引脚。 具体步骤 进入我们上一小节修改过的 MiaowLabs-Demo 文件夹，找到 MiaowLabs-Demo.ioc 工程文件，双击，打开工程。在左侧 Pinout&Configuration 界面中的 Connectivity 下拉中点击 I2C1，然后在 I2C1 Mode and Configuration 的 Mode 中将 I2C 选择为 I2C。而其他地方，比如 Configuration 中的 Parameter Setting 选项卡全部保持默认参数（标准模式，100k 速率）即可。 Image 5.11.1 - 使用 STM32CubeMX 配置 I2C1 接口 点击 GENERATE CODE，重新生成代码。 Image 5.11.2 - 重新生成代码 从光盘中找到已经用 STM32 HAL 库封装好的 MPU6050 代码文件： mpu6050.c、mpu6050.h，这两个文件主要就是使用 HAL 库里的 I2C 函数进行改写，可以直接调用。 将 mpu6050.c ，复制到 MiaowLabs-Demo 文件夹的 Src 文件夹里。 Image 5.11.3 - 将 `mpu6050.c` 复制到 Src 文件夹 将 mpu6050.h 复制到 MiaowLabs-Demo 文件夹的 Inc 文件夹里。 Image 5.11.4 - 将 `mpu6050.h` 复制到 Inc 文件夹 打开 MDK-ARM 软件，在左侧目录中双击 Application/User，将 Src 文件夹的 mpu6050.c 加入工程。 Image 5.11.5 - 将 Src 文件夹的 `mpu6050.c` 加入工程 打开 main.h 头文件，在 /* USER CODE BEGIN Includes */ 和 /* USER CODE END Includes */ 之间加入 mpu6050.h 文件： /* Private includes ----------------------------------------------------------*/ /* USER CODE BEGIN Includes */ #include \"button.h\" #include \"encoder.h\" #include \"mpu6050.h\" /* USER CODE END Includes */ Image 5.11.6 - 在 main.h 中加入 mpu6050.h 打开 main.c 文件，在 /* USER CODE BEGIN 1 */ 和 /* USER CODE END 1 */ 之间定义以下新变量，并且将上个实验的变量注释掉： /* USER CODE BEGIN 1 */ //int iTempTim4Encoder;///临时存放从TIM4编码器接口捕获到的脉冲数据 short accx,accy,accz;//加速度x轴、y轴、z轴数据 short gyrox,gyroy,gyroz;//陀螺仪x轴、y轴、z轴数据 /* USER CODE END 1 */ 在 /* USER CODE BEGIN 2 */ 和 /* USER CODE END 2 */ 之间敲入以下新代码，注释掉上个实验留下的代码： /* USER CODE BEGIN 2 */ if(!MPU_Init())//如果MPU6050初始化成功，返回0，!0则为1 { printf(\"MPU-6050 Init Successfully\");//成功了则打印 MPU-6050 Init Successfully } //HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_2);//开启TIM3_CH2的PWM输出 //HAL_GPIO_WritePin(BIN1_GPIO_Port, BIN1_Pin, GPIO_PIN_SET);//初始化BIN1引脚为低电平 //HAL_GPIO_WritePin(BIN2_GPIO_Port, BIN2_Pin, GPIO_PIN_RESET);//初始化BIN2引脚为高电平 /* USER CODE END 2 */ Image 5.11.7 - 代码截图 在主循环中敲入以下代码： /* USER CODE BEGIN WHILE */ while (1) { MPU_Get_Accelerometer(&accx,&accy,&accz);//获取MPU6050加速度数据 MPU_Get_Gyroscope(&gyrox,&gyroy,&gyroz);//获取MPU6050陀螺仪数据 printf(\"accx=%d,accy=%d,accz=%d\\n\",accx,accy,accz);//打印MPU6050加速度数据 printf(\"gyrox=%d,gyroy=%d,gyroz=%d\\n\",gyrox,gyroy,gyroz);//打印MPU6050陀螺仪数据 HAL_Delay(500); //延时0.5s，防止打印发送数据太快 } /* USER CODE END WHILE */ Image 5.11.8 - 代码截图 在 MDK-ARM 中重新编译代码，把代码烧录进小车的 MiaowLabs-STM32F1-Micro 核心板（小车提前组装好），并用数据线连接核心板和电脑，打开喵呜地面站或其他串口助手软件，我们用手按一下核心板的复位按钮，能够看到小车发送 MPU-6050 Init Successfully 到串口助手上，代表 MPU6050 初始化成功，而且每隔 0.5 秒就将加速度和陀螺仪数据发送上去，我们转动小车可以看到数据随之变化。 Image 5.11.9 - 串口助手截图 就这样，我们成功读取了 MPU6050 传感器的原始数据。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"B07.html":{"url":"B07.html","title":"加速度计、陀螺仪的工作原理和数据融合","keywords":"","body":"加速度计、陀螺仪的工作原理和数据融合 本小节主要讲解加速度传感器、陀螺仪的工作原理、姿态解算，并对两者进行数据融合。数据融合以讲解互补滤波的工作原理为主。 陀螺仪、加速度计都是惯性测量元件的一种。而 MPU-6050 传感器的内部同时集成了陀螺仪和加速度传感器两种惯性测量元件。 加速度传感器（又名加速度计） MPU-6050 传感器内部封装了陀螺仪和加速度传感器两种惯性测量元件，而陀螺仪和加速度传感器的工作原理是不一样的。我们先从加速度传感器开始进行了解。 Image 5.12.1 - 图片来自：starlino.com 为了便于理解，我们可以把加速度传感器想象为一个盒子模型——一个小球在一个方盒子中。 想象一下，如果把盒子模型放在真空环境中会怎么样？在真空中，一切东西都处于无重力状态（失重），这时，小球也不例外，将悬浮在盒子的中间。在上面的图中,你可以看到我们给每个轴分配了一对墙（为了观察里面的情况，我们移除了 Y+）。设想每面墙都能感测压力。如果我们突然把盒子向左移动（加速度为 1g=9.8m/s21g = 9.8m/s^21g=9.8m/s​2​​），那么球会撞上 X−X-X− 墙。然后我们检测球撞击墙面产生的压力，XXX 轴输出值为 −1g-1g−1g。 Image 5.12.2 - 图片来自：starlino.com 请注意加速度传感器检测到力的方向与它自身运动加速度的方向是相反的。这种力通常被称为惯性力 。在这个模型中，你能了解到加速度传感器是通过间接测量力对一个墙面的作用来测量加速度的，但在实际应用中，可能通过弹簧或其他装置来测量力。这个力可以是加速度引起的，但在下面的例子中，我们会发现它不一定是加速度引起的。 众所周知地球上的物体都会受到重力 g=9.8m/s2g = 9.8m/s^2g=9.8m/s​2​​ 的作用。如果我们把模型放在地球上，这时圆球不再是悬浮的，而是会落在Z-墙面上并对其施加一个 1g1g1g 的力，见下图： Image 5.12.3 - 图片来自：starlino.com 在这种情况下，盒子没有移动，但我们依然能读取到 ZZZ 轴有 −1g-1g−1g 的值。因为球在墙面上施加的压力是由重力造成的。在理论上，它可以是不同类型的引力。例如，你可以想象盒子里的圆球是铁质的，将一个磁铁放在盒子旁边，小球就会撞上另一面墙，这时圆球受到的是磁场力。引用这个例子只是为了说明加速度传感器的本质是检测力而非加速度。只是加速度所引起的惯性力正好能被加速度传感器的检测装置所捕获。 虽然这个盒子模型并非一个 MEMS 传感器的真实构造，但它用来解决与加速度传感器相关的问题相当有效。实际上有些类似传感器中有金属小球，它们称作倾角开关，但是它们的功能更弱，只能检测设备是否在一定程度内倾斜，却不能得到倾斜的程度。 到目前为止，我们已经分析了单轴的加速度传感器输出。三轴加速度传感器的真正价值在于它们能够检测全部三个轴的惯性力。让我们回到盒子模型，并将盒子向右旋转 45 度。盒子模型依然是放在地球上。现在球会与两个面接触：Z−Z-Z− 和 X−X-X−，见下图： Image 5.12.4 - 图片来自：starlino.com 其中，0.71g0.71g0.71g 这个值是不是随意写上去的，它们实际上是 (1/2)\\sqrt(1/2)√​(​​​1/2) 的近似值。这是根据勾股定理计算出来的，具体计算方法我们介绍加速度传感器的下一个模型时这一点会更清楚。 在上一个模型中，我们引入了重力并旋转了盒子。在最后的两个例子中我们分析了盒子在两种情况下的输出值，力矢量保持不变。虽然这有助于理解加速度传感器是怎么和外部力相互作用的，但如果我们将坐标系换为加速度的三个轴并想象矢量力在周围旋转，这会更方便计算。 Image 5.12.5 - 图片来自：starlino.com 其中， Rx、Ry、Rz 是向量 R 分别在 X、Y、Z 轴上的投影， Rxz 是向量 R 在 XZ 平面上的投影； Ryz 是向量 R 在 YZ 平面上的投影； Axz 是 Rz 和 Rxz 之间的夹角； Ayz 是 Rz 和 Ryz 之间的夹角； 根据勾股定理，求得： tan(Axz) = Rx / Rz tan(Ayz) = Ry / Rz 那么，通过反正切函数 atan() 可得： Axz = atan(Rx/Rz) Ayz = atan(Ry/Rz) 我们感兴趣的角度是 Axz、Ayz。请看看在上面的模型，我保留了轴的颜色，以便你的思维能更好的从上一个模型转到新的模型中。想象新模型中每个轴都分别垂直于原模型中各自的墙面。矢量 R 是加速度传感器所检测的矢量（它可能是重力或上面例子中惯性力的合成）。Rx，Ry，Rz 是矢量 R 在 X，Y，Z 轴上的投影。 根据三维空间勾股定理，可以得到下列关系： R2=Rx2+Ry2+Rz2R^2 = R_x^2 + R_y^2 + R_z^2R​2​​=R​x​2​​+R​y​2​​+R​z​2​​（公式1） 还记得我刚才说的 12=0.71\\sqrt{\\frac {1}{2}}=0.71√​​2​​1​​​​​=0.71 吧。如果你把它们代回上式，回顾一下重力加速度是 1g1g1g ，那我们就能验证： 12=(−12)2+0+(−12)21^2 = (-\\frac {1}{2} )^2 + 0 + (-\\frac {1}{2} )^21​2​​=(−​2​​1​​)​2​​+0+(−​2​​1​​)​2​​ 回到 MPU-6050 传感器中，在上一小节我们已经分别读取到 3 个轴的加速度数据，但是我们读到的加速度数字量的单位还不是 g(9.8m/s2)g(9.8m/s^2)g(9.8m/s​2​​)。最后的转换，我们还需要引入加速度传感器的灵敏度（Sensitivity），单位通常是 LSB/gLSB/gLSB/g。比方说，加速度传感器的灵敏度 Sensitivity=16384LSB/gSensitivity = 16384LSB/gSensitivity=16384LSB/g。灵敏度值可以在加速度传感器规格书中找到。要获得最后的单位为 ggg 的加速度，我们使用下列公式计算： Rx=Rx/SensitivityRx = Rx / SensitivityRx=Rx/Sensitivity 比如： 当设置 MPU-6050 加速度传感器的灵敏度为 16384LSB/g，读取 MPU-6050 的 X、Z 轴加速度数据为 1122、16674 时，则可以计算出： Rx=1122LSB/16384LSB/g=0.068gRx = 1122LSB / 16384LSB/g = 0.068gRx=1122LSB/16384LSB/g=0.068g Rz=16674LSB/16384LSB/g=1.018gRz = 16674LSB / 16384LSB/g = 1.018gRz=16674LSB/16384LSB/g=1.018g Axz=atan(0.068g/1.018g)=0.589radAxz = atan(0.068g / 1.018g) = 0.589radAxz=atan(0.068g/1.018g)=0.589rad 注意，这时求出来的角度单位为 弧度 rad，和我们日常习惯用的单位 角度 °之间有条转换公式： Angle=Radian/π∗180Angle = Radian / \\pi * 180Angle=Radian/π∗180 那么， Axz=0.589rad/π∗180=33.7Axz = 0.589rad / \\pi * 180 = 33.7Axz=0.589rad/π∗180=33.7° 陀螺仪 对于陀螺仪，我们不会像加速度传感器一样介绍它的等价盒子模型，而是直接跳到加速度传感器的第二个模型，通过这个模型向大家介绍陀螺仪是怎么工作的。 Image 5.12.6 - 图片来自：starlino.com 陀螺仪的每个通道检测一个轴的旋转。例如，一个 2 轴陀螺仪检测绕 X 和 Y 轴的旋转。为了用数字来表达这些旋转，我们先引进一些符号。首先，我们定义： Rxz – 惯性力矢量 R 在 XZ 平面上的投影 Ryz – 惯性力矢量 R 在 YZ 平面的上投影 在由 Rxz 和 Rz 组成的直角三角形中，运用勾股定理可得： Rxz2=Rx2+Rz2Rxz^2 = Rx^2 + Rz^2Rxz​2​​=Rx​2​​+Rz​2​​ 同样： Ryz2=Ry2+Rz2Ryz^2 = Ry^2 + Rz^2Ryz​2​​=Ry​2​​+Rz​2​​ 同时注意： R2=Rxz2+Ry2R^2 = Rxz^2 + Ry^2R​2​​=Rxz​2​​+Ry​2​​ 这条公式可以公式 1 和上面的公式推导出来，也可由 R 和 Ryz 所组成的直角三角形推导出来 同样： R2=Ryz2+Rx2R^2 = Ryz^2 + Rx^2R​2​​=Ryz​2​​+Rx​2​​ 在本小节中我们不会用到这些公式，但知道模型中的那些数值间的关系有助于理解。 相反，我们按如下方法定义 Z 轴和 Rxz、Ryz 向量所成的夹角： AxzAxzAxz - RxzRxzRxz（矢量 RRR 在 XZXZXZ 平面的投影）和 ZZZ 轴所成的夹角 AyzAyzAyz - RyzRyzRyz（矢量 RRR 在 YZYZYZ 平面的投影）和 ZZZ 轴所成夹角 现在我们离陀螺仪要测量的东西又近了一步。陀螺仪测量上面定义的角度的变化率。换句话说，它会输出一个与上面这些角度变化率线性相关的值。为了解释这一点，我们先假设在 t0 时刻，我们已测得绕 Y 轴旋转的角度（也就是 Axz），定义为 Axz0，之后在 t1 时刻我们再次测量这个角度，得到 Axz1。角度变化率按下面方法计算： RateAxz=(Axz1−Axz0)/(t1−t0)RateAxz = (Axz1 - Axz0) / (t1 - t0)RateAxz=(Axz1−Axz0)/(t1−t0) 如果用度来表示角度，秒来表示时间，那这个值的单位就是 度/秒。这就是陀螺仪检测的东西。在实际运用中，陀螺仪一般都不会直接给你输出一个单位为度/秒的值（除非它是个特殊的数字陀螺仪）。在 MPU-6050 传感器中，就像读取加速度数据一样，你会得到一个经过内置 ADC 转换后得到的数字量，单位为 LSBLSBLSB。参考对加速度数据的处理，我们同样得到： RateAxz=(GyroX−ZeroRate)/SensitivityRateAxz = (GyroX - ZeroRate) / SensitivityRateAxz=(GyroX−ZeroRate)/Sensitivity 公式3 RateAyz=(GyroY−ZeroRate)/SensitivityRateAyz = (GyroY - ZeroRate) / SensitivityRateAyz=(GyroY−ZeroRate)/Sensitivity 其中， GyroX，GyroY - 这两个值是陀螺仪数据，它们分别代表矢量 R 的投影在 XZ 和 YZ 平面内里的转角，也可等价的说，旋转可分解为单独绕 Y 和 X 轴的运动。 ZeroRate – 陀螺仪零偏值，换句话说，它是陀螺仪静止不动时的输出值。理论上，陀螺仪静止不动时，应该输出为 0 的值，但是受制造工艺、外部因素的影响，陀螺仪静止不动时输出一个比较小的随机的不为 0 的值，我们称之为零偏值。 Sensitivity – 陀螺仪的灵敏度，单位 LSB/(deg/s)，它的意思就是如果旋转速度增加 1°/s，陀螺仪的输出就会增加多少 LSB。灵敏度在规格书中可以查到的。 举个例子，假设我们读取到 MPU-6050 传感器的 X 轴数据： GyroX = 12345 若此时设置陀螺仪的灵敏度为 16.4LSB/deg/s，并认为陀螺仪零偏值为 0，代入公式 3 ，得到： RateAxz=(12345−0)/16.4LSB/deg/s=751deg/sRateAxz = (12345 - 0) / 16.4LSB/deg/s = 751 deg/sRateAxz=(12345−0)/16.4LSB/deg/s=751deg/s 换句话说，传感器绕 X 轴（或者说 YZ 平面内）以 751°/s 的速度旋转。请注意，因为陀螺仪输出值有正负之分，负号表示该传感器朝着反方向旋转。一份好的传感器规格书会告诉你哪个方向是正的，否则你就要自己测试出哪个旋转方向会使得输出值增加。 融合加速度传感器和陀螺仪的数据 惯性测量元件包括多种传感器，比如倾角仪、加速度计、陀螺仪、罗盘等传感器。每种惯性测量元件的性能都不尽相同，对比分析表格如下表所示： 测量值 优点 缺点 倾角仪 角度 静态性能好，精度高，无累积误差 动态响应速度慢 加速度传感器 加速度 静态性能好，精度高，更新频率快 存在累积漂移误差，动态响应慢 陀螺仪 角速度 动态响应好，频带宽，更新频率快 存在温漂和零漂 罗盘 角度 静态性能好，精度高，无漂移误差 动态响应速度慢，受环境磁场影响大 倾角仪测量与重力方向相关的姿态角，输出频率低，实时性较差，而且输出信号容易受噪声污染。对相频特性进行分析显示，倾角仪相位存在滞后。 加速度传感器测量与惯性有关的加速度，包括旋转、重力和线性加速度，对测量数据进行积分可以得到线性速度，二次积分可以得到线位移，但积分产生的漂移误差将随时间累积而无限制地增长导致积分后得到的数据不准确。加速度传感器通过三角函数运算可获得倾角值，但是输出信号容易受噪声污染。当加速度传感器垂直于俯仰角安装时，通过反正切函数运算可以作为倾角仪使用进行360°的全方位测量，并且不会产生线性化误差。 陀螺仪测量瞬时旋转角速度，由于温度变化、摩擦力、不稳定力矩等因素，会产生漂移误差。对陀螺仪测量数据进行积分可以得到与垂直方向相关的倾角信息，动态响应快，但漂移误差将随时间累积而无限增长。陀螺仪具有足够的带宽，动态性能好，静态输出受漂移误差影响较大。 罗盘通过测量相对于地磁场的方向，提供绝对姿态角信息。由于室内存在电源线和钢结构导致磁场产生畸变，罗盘一般不适于室内工作。 在上面的加速度传感器部分，我们似乎只要读取到加速度数据，通过反正切函数 atan() 就能求出我们想要的角度，再对此信号进行微分便可以获得角速度。但是在实际运用环境中，比如两轮自平衡小车，由于小车本身的摆动所产生的加速度会产生很大的干扰信号，它叠加在上述加速度数据量上使得该数据无法准确反映小车的倾角。 陀螺仪可以用来测量物体的旋转角速度。由于陀螺仪输出的是小车的角速度，不会受到小车运动的影响，因此该信号中噪声很小。小车的倾角又是通过对角速度积分而得，这可进一步平滑信号，从而使得角度信号更加平稳。因此，小车控制所需要的角度和角速度可以使用陀螺仪所得到的数据量。 由于从陀螺仪角速度获得角度信息，需要经过积分运算。如果角速度信号存在微小的偏差和漂移，经过积分运算之后，变化形成积累误差。这个误差会随着时间延长逐步增加，最终导致电路饱和，无法形成正确的角度信号。 如何消除这个累计误差呢？ 一种简单的方法就是使用数据融合算法。通过上面的加速度传感器获得的角度信息对此进行校正。通过对比积分所得到的的角度与重力加速度所得到的的角度，使用它们之间的偏差改变陀螺仪输出，从而积分的角度逐步跟踪到加速度传感器所得到的的角度。 数据融合算法有很多，目前流行使用的有两种： 互补滤波（complementary filter） 卡尔曼滤波（kalman filter） 萌新们可能会纳闷：我这里要学的是数据融合算法，为啥扔给我两个滤波算法？为啥不是学“互补融合”、“卡尔曼融合”？ 要知道，数据滤波是去除噪声还原真实数据的一种数据处理技术。任何的数据融合都是为了将多种途径的数据中的噪声滤波，以达到尽可能接近真实值的目的。从这个角度理解，将多种数据融合只是表象，滤除了信号中的噪声才是本质。 互补滤波和卡尔曼滤波都是能去除加速度传感器和陀螺仪的噪声，取得精准的姿态数据。其中，互补滤波简单易懂，适合萌新们初学入门使用。 互补滤波（complementary filter） 2007年，MIT 大神 Shane Colton 发表了经典论文《The Balance Filter》，里面提出了一种对加速度传感器与陀螺仪进行数据融合的有效方法——互补滤波。互补滤波包括低通滤波（滤除或衰减短期加速度传感器波动），以及高通滤波（消除漂移对陀螺仪的影响）。 在加速度传感器部分，我们通过反正切函数求出了角度，这里用 Acc 表示；在陀螺仪部分，我们得到了角速度，这里用 Gyro表示。 互补滤波的核心公式： Angle=0.98∗(Angle+Gyro∗dt)+0.02∗AccAngle = 0.98 * (Angle + Gyro * dt) + 0.02 * AccAngle=0.98∗(Angle+Gyro∗dt)+0.02∗Acc 其中， Angle 为经过互补滤波后得到的角度 Gyro 为陀螺仪部分得到的角速度 Acc 为加速度传感器部分通过反正切函数 atan() 再转换单位后的角度 dt 为滤波器的运行周期 0.98 和 0.02 为加权系数 α\\alphaα 和 (1−α)(1 - \\alpha)(1−α) 使用 c 语言把互补滤波封装成函数： // a = tau / (tau + dt) // acc = 加速度传感器数据 // gyro = 陀螺仪数据 // dt = 运行周期 float angle; float a; float ComplementaryFliter(float acc, float gyro, float dt) { a = 0.98; angle = a * (angle + gyro * dt) + (1 - a) * (acc); return angle; } 在互补滤波公式中，像陀螺仪角速度、加速度角度这些数据可以直接从陀螺仪、加速度传感器中读取得到。可是，加权系数是怎么得来的呢？ 在《The Balance Filter》中提到关于 加权系数的求解公式。在这里，先设滤波器的加权系数为 α\\alphaα，时间常数为为 τ\\tauτ，运行周期为 dtdtdt，那么公式为： α=τ/(τ+dt) \\alpha = \\tau / (\\tau + dt)α=τ/(τ+dt) 运行周期 dtdtdt 通常都是我们设定的。比如在程序里，我们打算让互补滤波器在 1s(=1000ms)1s(=1000ms)1s(=1000ms) 中运行 200 次，那么dt=1000ms/200hz=5msdt = 1000ms / 200hz = 5msdt=1000ms/200hz=5ms。 时间常数 τ\\tauτ 的取值是由我们根据系统的实际滤波需求调整的，每个不同的系统的 τ\\tauτ 值都不一定相同。时间常数 τ\\tauτ 是“信任”陀螺仪和“信任”加速度传感器的边界值。若时间常数 τ\\tauτ 取值越大，则更加“信任”陀螺仪积分，但跟随加速度传感器的速度会变慢。若时间常数 τ\\tauτ 取值越小，则更加“信任”加速度传感器，但同时引入加速度传感器中更多的噪声。通常，互补滤波器是为了得到更“纯”的融合角度，必须要“信任”陀螺仪积分多些，以削弱加速度传感器中噪声的影响。 比如，互补滤波器放在 10ms(=0.01s)10ms (= 0.01s)10ms(=0.01s) 周期中循环运行，时间常数 τ=0.49\\tau = 0.49τ=0.49，那么，此时加权系数为： α=τ/(τ+dt)=0.49/(0.49+0.01)=0.98 \\alpha = \\tau / (\\tau + dt) = 0.49 / (0.49 + 0.01) = 0.98α=τ/(τ+dt)=0.49/(0.49+0.01)=0.98 函数的入口参数是加速度传感器数据、陀螺仪数据和运行周期。经过计算后，函数返回融合角度。 为了更进一步了解加权系数的作用，我们留意两个极值情况： 当 a=1a = 1a=1 时，那么滤波器变成 angle=1∗(Angle+Gyro∗dt)+(1−1)∗Acc=Angle+Gyro∗dtangle = 1 * (Angle + Gyro * dt) + (1 - 1) * Acc = Angle + Gyro * dtangle=1∗(Angle+Gyro∗dt)+(1−1)∗Acc=Angle+Gyro∗dt，失去了加速度传感器的修正效果，变成了一个纯粹的陀螺仪积分器，此时互补滤波器完全信任陀螺仪。 当 a=0a = 0a=0 时，那么滤波器变成 angle=0∗(Angle+Gyro∗dt)+(1−0)∗Acc=Accangle = 0 * (Angle + Gyro * dt) + (1 - 0) * Acc = Accangle=0∗(Angle+Gyro∗dt)+(1−0)∗Acc=Acc，此时陀螺仪完全失去了作用，融合角度直接等于加速度传感器数值，此时互补滤波器完全信任加速度传感器。 由此可见，加权系数 α\\alphaα 值的大小决定了互补滤波器是信任陀螺仪还是信任加速度传感器多一些，也直接决定了互补滤波器的效果。 当然，互补滤波器也存在缺陷： 初始化时不能及时跟随实际角度。这种情况，跟融合角度变量没有正确初始化和互补滤波器的时间常数取值有关。时间常数约大，陀螺仪积分比重越大，跟随加速度传感器的速度约慢，这意味着初始化时融合角度可能是不精准的。 陀螺仪的零漂问题。理论上，陀螺仪在静止的时候，读出来的数值应该为 0，但实际上往往不为 0，这个值被称为零偏值。陀螺仪每次上电后的零偏值是随机的。互补滤波器并不能有效地过滤掉陀螺仪的零漂。 下一小节，我们将教你把互补滤波实际应用到实际项目中去。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A27.html":{"url":"A27.html","title":"MPU6050姿态解算和数据融合","keywords":"","body":"MPU-6050姿态解算和数据融合 本小节对 MPU-6050 传感器的原始数据进行姿态解算，然后再利用数据融合算法得到精准的角度。 在上两小节中，我们已经读到 MPU-6050 传感器的原始数据，学习了加速度传感器、陀螺仪的工作原理、姿态解算，并对互补滤波有所了解。在本小节中，我们结合 STM32CubeMX、MDK-ARM 软件，对 MPU-6050 传感器数据进行姿态解算和数据融合。 具体步骤 进入我们上一小节修改过的 MiaowLabs-Demo 文件夹，再打开里面的 MDK-ARM 文件夹，找到 MiaowLabs-Demo.uvprojx 工程文件，双击，打开工程。在 MDK-ARM 工程界面，按下组合键 Ctrl+N（按住 Ctrl 键再按 N 键），新建一个文件，再按下组合键 Ctrl+S，文件名改为 filter.c，保存到 MiaowLabs-DEMO 的 Src 文件夹里，接着在 MDK-ARM 工程界面左侧 Project 栏目双击 Application/User 文件夹，把 filter.c 加进来。 双击 filter.c 源文件，敲入以下代码： #include \"filter.h\"//加入头文件 //互补滤波器 // a = tau / (tau + dt) // acc = 加速度传感器数据 // gyro = 陀螺仪数据 // dt = 运行周期 float angle; float a; float ComplementaryFilter(float acc, float gyro, float dt) { a = 0.98; angle = a * (angle + gyro * dt) + (1 - a) * (acc); return angle; } Image 5.13.1 - 代码截图 filter.c 源文件中暂时就只是封装了一个互补滤波的函数。 上面代码添加了头文件，但我们还没创建头文件呢，再新建一个文件 filter.h 头文件，把文件保存到 Inc 文件夹。然后，把下面代码敲进去。 #ifndef __FILTER_H #define __FILTER_H float ComplementaryFilter(float acc, float gyro, float dt); #endif 在 MDK-ARM 工程界面，按下组合键 Ctrl+N（按住 Ctrl 键再按 N 键），新建一个文件，再按下组合键 Ctrl+S，文件名改为 control.c，保存到 MiaowLabs-DEMO 的 Src 文件夹里，接着在 MDK-ARM 工程界面左侧 Project 栏目双击 Application/User 文件夹，把 control.c 加进来。 双击 control.c 源文件，敲入以下代码： #include \"control.h\" #include \"filter.h\" #include \"mpu6050.h\" #include \"math.h\" short x_nAcc,y_nAcc,z_nAcc;//加速度x轴、y轴、z轴数据 short x_nGyro,y_nGyro,z_nGyro;//陀螺仪x轴、y轴、z轴数据 float x_fAcc,y_fAcc,z_fAcc; float g_fAccAngle;//加速度传感器经过atan2()解算得到的角度 float g_fGyroAngleSpeed;//陀螺仪角速度 float g_fCarAngle;//小车倾角 float dt = 0.005;//互补滤波器控制周期 unsigned char g_ucMainEventCount;//主事件计数，会用在中断中 void GetMpuData(void)//获取MPU-6050数据函数 { MPU_Get_Accelerometer(&x_nAcc,&y_nAcc,&z_nAcc);//获取MPU-6050加速度数据 MPU_Get_Gyroscope(&x_nGyro,&y_nGyro,&z_nGyro); //获取MPU-6050陀螺仪数据 } void AngleCalculate(void)//角度计算函数 { //-------加速度数据处理-------------------------- //量程为±2g时，灵敏度：16384 LSB/g x_fAcc = x_nAcc / 16384.0; y_fAcc = y_nAcc / 16384.0; z_fAcc = z_nAcc / 16384.0; g_fAccAngle = atan2(y_fAcc,z_fAcc) / 3.14 * 180.0; //-------陀螺仪数据处理------------------------- //范围为2000deg/s时，换算关系：16.4 LSB/(deg/s) g_fGyroAngleSpeed = x_nGyro / 16.4; //计算角速度值 //-------互补滤波--------------- g_fCarAngle = ComplementaryFilter(g_fAccAngle, g_fGyroAngleSpeed, dt); } Image 5.13.2 - 代码截图 函数 GetMpuData() 的主要作用，就是分别获取 MPU-6050 传感器的三轴加速度、三轴陀螺仪数据，并将数据存入 x_nAcc、y_nAcc、z_nAcc、x_nGyro、y_nGyro、z_nGyro 变量中。 函数 AngleCalculate() 的主要作用，就是先将加速度数据除于灵敏度，将加速度数据由 LSB 转化成 g，注意这时变量类型为了保持精度为使用了 float 类型，再使用 atan2() 函数计算出角度，这时的角度单位为弧度，先除 3.14 再乘 180°，将单位转换成我们日常用的度。然后，将陀螺仪数据除于灵敏度，得到角速度，单位为 deg/s。最后，将加速度初算的角度和陀螺仪角速度送入互补滤波器进行数据融合，得到最终的稳定的精准的小车倾角。 注意这里我们定义 dt = 0.005，即 5ms，要怎么样才能实现精准的 5ms 运行一次呢？放在主循环中是不可靠的，因为按顺序运行，无法精确地控制时间。唯有靠定时中断，我们可以将关键代码放在我们先前用过的 SysTick_Handler() 滴答定时器中断服务函数中，以期实现精准的运行。 添加 math.h 头文件，才可以正常使用 atan2() 反正切函数。 再新建一个文件 control.h 头文件，把文件保存到 Inc 文件夹。然后，把下面代码敲进去： #ifndef __CONTROL_H #define __CONTROL_H #include \"filter.h\" extern unsigned char g_ucMainEventCount; extern float g_fCarAngle; void GetMpuData(void); void AngleCalculate(void); #endif Image 5.13.3 - 代码截图 打开 main.h 头文件，将 control.h 头文件添加进去。 #include \"control.h\" Image 5.13.4 - 代码截图 这里不把 filter.h 头文件添加进去，我们已经在 control.h 里面包含了 filter.h 头文件，因此不必在这里再重复添加。 在 MDK-ARM 左侧 Application/User 文件夹中，找到 stm32f1xx_it.c 源文件，双击打开，将以下代码敲入 SysTick_Handler() 函数中： /* USER CODE BEGIN SysTick_IRQn 0 */ g_ucMainEventCount++; if(g_ucMainEventCount>=5) { g_ucMainEventCount=0; GetMpuData(); //读取MPU6050数据函数，每5ms执行一次 AngleCalculate(); //角度环计算函数，每5ms执行一次 } /* USER CODE END SysTick_IRQn 0 */ Image 5.13.5 - 代码截图 在 main.c 主循环中添加以下代码： printf(\"小车角度 = %f\",g_fCarAngle);//打印实时角度 HAL_Delay(500);//延时0.5s，防止打印发送数据太快 HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);//指示灯 点击编译按钮，重新进行编译，这时没有报错。但是烧录代码会发现不仅数据发送不出，甚至连指示灯都不闪烁。 注意中断服务函数里的代码： /* USER CODE BEGIN SysTick_IRQn 0 */ g_ucMainEventCount++; if(g_ucMainEventCount>=5) { g_ucMainEventCount=0; GetMpuData(); //读取MPU6050数据函数，每5ms执行一次 AngleCalculate(); //角度环计算函数，每5ms执行一次 } /* USER CODE END SysTick_IRQn 0 */ 因为这段代码是在 1ms 内运行完，所以要确保函数 GetMpuData() 和 AngleCalculate() 能在 1ms 内就运行完毕。 而函数 GetMpuData() 里面的 函数 MPU_Get_Accelerometer() 和 MPU_Get_Gyroscope() 都调用了 MPU_Read_Len() 这个函数，里面有一句延时代码 HAL_Delay(100);。也就是说，运行完这段代码要 100ms+ 的时间，在 1ms 中断里根本运行不完，压根没有时间给到主循环执行其他代码，所以发送不出数据，指示灯也不闪。 我们将延时函数 HAL_Delay(100); 注释掉，加快 I2C 读取速度，并不影响 I2C 正常工作。 Image 5.13.6 - 注释掉延时函数 点击编译按钮，重新进行编译，这时没有报错。将代码烧录进小车中，会看到指示灯每 0.5s 闪烁一次。 插上 Micro-USB 数据线，打开串口助手，可以看到随着小车倾斜角度变化，发送到串口助手上的数据也随之变化。 Image 5.13.7 - 得到精准的角度 使用虚拟示波器 使用 printf() 函数打印输出角度到串口助手上，虽然可以看到大致的角度效果，但不够直观，而且无法看到加速度、陀螺仪、融合后的角度之间的联系。接下来，我们将加速度、陀螺仪、角度等参数，通过虚拟示波器转化成曲线输出，更加直观地观察数据之间的关系。 进入 MiaowLabs-Demo 文件夹，再打开里面的 MDK-ARM 文件夹，找到 MiaowLabs-Demo.uvprojx 工程文件，双击，打开工程。 从光盘中找到虚拟示波器上位机的 API 代码文件： outputdata.c、outputdata.h，这两个文件主要就是将发送到虚拟示波器的协议和校验等等功能都已经封装好了，我们只需要修改最后的发送函数，就可以调用。 将 outputdata.c ，复制到 MiaowLabs-Demo 文件夹的 Src 文件夹里。 Image 5.13.8 - 复制 outputdata.c 到 Src 文件夹 将 outputdata.h 复制到 MiaowLabs-Demo 文件夹的 Inc 文件夹里。 Image 5.13.9 - 复制 outputdata.h 到 Inc 文件夹 打开 MDK-ARM 软件，在左侧目录中双击 Application/User，将 Src 文件夹的 outputdata.c 加入工程。 Image 5.13.10 - 将 Src 文件夹的 `outputdata.c` 加入工程 双击打开 outputdata.c 源文件，对两个地方进行修改。 第一个地方是注释掉原来的头文件 uart.h，把我们用到的头文件 usart.h 添加进来。 #include \"outputdata.h\" //#include \"uart.h\" #include \"usart.h\" 第二个地方是修改发送函数，将原句 uart_putchar(databuf[i]); 注释掉，改为 HAL 库的发送函数 HAL_UART_Transmit(&huart1,&databuf[i],1,0xFF);。 void OutPut_Data(void) { int temp[4] = {0}; unsigned int temp1[4] = {0}; unsigned char databuf[10] = {0}; unsigned char i; unsigned short CRC16 = 0; for(i=0;i 下面给出 outputdata.c 源文件修改之后的全部代码，以便萌新们进行参考。 #include \"outputdata.h\" //#include \"uart.h\" #include \"usart.h\" float OutData[4] = { 0 }; unsigned short CRC_CHECK(unsigned char *Buf, unsigned char CRC_CNT) { unsigned short CRC_Temp; unsigned char i,j; CRC_Temp = 0xffff; for (i=0;i>1 ) ^ 0xa001; else CRC_Temp = CRC_Temp >> 1; } } return(CRC_Temp); } void OutPut_Data(void) { int temp[4] = {0}; unsigned int temp1[4] = {0}; unsigned char databuf[10] = {0}; unsigned char i; unsigned short CRC16 = 0; for(i=0;i 分别在 control.c、main.h 文件里面添加 outputdata.h 头文件。 Image 5.13.11 - 在 control.c 里添加 outputdata.h 头文件 Image 5.13.12 - 在 main.h 里添加 outputdata.h 头文件 在 control.c 文件里的 AngleCalculate() 函数中，把要发送的数据分别送入输出数组中。 void AngleCalculate(void) { //-------加速度数据处理-------------------------- //量程为±2g时，灵敏度：16384 LSB/g x_fAcc = x_nAcc / 16384.0; y_fAcc = y_nAcc / 16384.0; z_fAcc = z_nAcc / 16384.0; g_fAccAngle = atan2(y_fAcc,z_fAcc) * 180.0 / 3.14; //-------陀螺仪数据处理------------------------- //范围为2000deg/s时，换算关系：16.4 LSB/(deg/s) g_fGyroAngleSpeed = x_nGyro / 16.4; //计算角速度值 //-------互补滤波--------------- g_fCarAngle = ComplementaryFilter(g_fAccAngle, g_fGyroAngleSpeed, dt); OutData[0]=g_fAccAngle;//发送加速度初步计算的角度 OutData[1]=g_fGyroAngleSpeed;//发送陀螺仪角速度 OutData[2]=g_fCarAngle;//发送数据融合得到的角度 } Image 5.13.13 - 修改 AngleCalculate() 函数 在 main.c 文件的主循环中注释掉或删掉之前实验的代码，添加调用虚拟示波器的发送函数。 while (1) { //printf(\"小车角度 = %f\",g_fCarAngle); //HAL_Delay(500);//延时0.5s，防止打印发送数据太快 //HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin); OutPut_Data();//调用虚拟示波器的发送函数 } Image 5.13.14 - 调用虚拟示波器的发送函数 用数据线连接小车，打开虚拟示波器，然后点击左上方菜单栏的 Setup 栏， 选择对应的 COM 口，波特率选择 115200。 Image 5.13.15 - 设置虚拟示波器 设置好之后，电机右下角的 RUN 按钮，就会开始显示波形，由于坐标系默认数值比较大，而我们要显示的数据数值又比较小，可能一开始几乎看不到波形。 Image 5.13.16 - 几乎看不见波形 别慌，这时候我们点击上面的工具栏，可以分别逐步放大 X 轴和 Y 轴，直至显示清晰的波形。 Image 5.13.17 - 放大看到清晰的波形 虚拟示波器的 4 个通道，分别对应代码里的数组 OutData[4] 的四个数据。在这里，刚才我们将加速度数据赋给 OutData[0]，所以加速度数据对应 CH1 通道，即红线。以此类推，黄线代表陀螺仪角速度，蓝线代表数据融合后的角度。因为我们没有重新赋值给 OutData[3]，即通道 4，所以它默认的数值为 0，在上位机中只是一条直线。 通过上面的波形可以看到，经过滤波后的角度值，能非常迅速地跟踪到加速度数据，又没有加速度数据那么多噪音，这就是我们想要的效果。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"E08.html":{"url":"E08.html","title":"PID控制原理与增量式PID算法","keywords":"","body":"PID控制原理与增量式PID算法 本小节纯粹在理论上讲解 PID 控制原理，先引出模拟 PID 控制公式，然后离散化处理，推导出位置式 PID 控制公式，再进一步推导出增量式 PID 控制公式。 将偏差的比例（Proportion）、积分（Integral）和微分（Differential）通过线性组合构成控制量，用这一控制量对被控对象进行控制，这样的控制器称 PID 控制器。 模拟 PID 控制 在模拟控制系统中，控制器最常用的控制规律是 PID 控制。为了说明控制器的工作原理，先看一个例子。下图所示是一个小功率直流电机的调速框图。 Image 5.14.1 - 小功率直流电机调速系统 上图中，给定转速 n0(t)n_0(t)n​0​​(t) 与实际转速 n(t)n(t)n(t) 进行比较，其差值 e(t)=n0(t)−n(t)e(t)=n_0(t)-n(t)e(t)=n​0​​(t)−n(t)，经过 PID 控制器调整后输出电压控制信号 u(t)u(t)u(t)，u(t)u(t)u(t) 经过功率放大后，驱动直流电动机改变其转速。 抽象化的模拟 PID 控制系统原理框图，如下图所示。该系统由模拟 PID 控制器和被控对象组成。 Image 5.14.2 - 模拟 PID 控制系统原理图 图中，r(t)r(t)r(t) 是给定值，y(t)y(t)y(t) 是系统的实际输出值，给定值与实际输出值构成控制偏差： e(t)=r(t)−y(t)e(t)=r(t)-y(t)e(t)=r(t)−y(t) （式 1-1） e(t)e(t)e(t) 作为 PID 控制的输入， 作为 PID 控制器的输出和被控对象的输入。 所以模拟 PID 控制器的 控制规律为 u(t)=kp[e(t)+1Ti∫e(t)dt+Tdde(t)dt]u(t)=kp[e(t)+\\frac{1}{Ti}\\int e(t)dt+Td\\frac{de(t)}{dt}]u(t)=kp[e(t)+​Ti​​1​​∫e(t)dt+Td​dt​​de(t)​​] （式 1-2） 其中，KpK_pK​p​​ 为控制器的比例系数，TiT_iT​i​​ 为控制器的积分时间，也称积分系数，TdT_dT​d​​为控制器的微分时间，也称微分系数。 数字 PID 控制 由于计算机的出现，计算机进入了控制领域。人们将模拟 PID 控制规律引入到计算机中来。对（式 1-2）的 PID 控制规律进行适当的变换，就可以用软件实现 PID 控制，即数字 PID 控制。 数字式 PID 控制算法可以分为位置式 PID 和增量式 PID 控制算法。 位置式 PID 算法 由于计算机控制是一种采样控制，它只能根据采样时刻的偏差计算控制量，而不能像模拟控制那样连续输出控制量，进行连续控制。由于这一特点，（式 1-2）中的积分项和微分项不能直接使用，必须进行离散化处理。离散化处理的方法为：以 T 作为采样周期，k 作为采样序号，则离散采样时间 kT对应着连续时间 t，用矩形法数值积分近似代替积分，用一阶后向差分近似代替微分，可作如下近似变换： t≈kT(k=0,1,2,...) t\\approx kT (k = 0,1,2,...) t≈kT(k=0,1,2,...) ∫e(t)dt≈T∑j=0ke(jT)=T∑j=0kej\\int e(t)dt\\approx T\\sum_{j=0}^{k} e(jT) = T\\sum_{j=0}^{k} e_j∫e(t)dt≈T∑​j=0​k​​e(jT)=T∑​j=0​k​​e​j​​ de(t)dt≈e(kT)−e[(k−1)T]T=ek−ek−1T\\frac{de(t)}{dt} \\approx \\frac{e(kT)-e[(k-1)T]}{T} = \\frac{e_k-e_{k-1}}{T}​dt​​de(t)​​≈​T​​e(kT)−e[(k−1)T]​​=​T​​e​k​​−e​k−1​​​​ 上式中，为了表达的方便，将类似于 e(kT)e(kT)e(kT) 简化成 eke_ke​k​​ 等。 将（式 2-1）代入（式 1-2），就可以得到离散的 PID 表达式为 uk=Kp[ek+(T)Ti∑j=0kej+Td(ek−ek−1)T] u_k = Kp[e_k+\\frac{(T)}{Ti}\\sum_{j=0}^{k}e_j+Td\\frac{(e_k-e_{k-1})}{T}]u​k​​=Kp[e​k​​+​Ti​​(T)​​∑​j=0​k​​e​j​​+Td​T​​(e​k​​−e​k−1​​)​​] （式 2-2） 或 uk=Kp∗ek+Ki∑j=0kej+Kd(ek−ek−1)T u_k = Kp*e_k+Ki\\sum_{j=0}^{k}e_j+Kd\\frac{(e_k-e_{k-1})}{T}u​k​​=Kp∗e​k​​+Ki∑​j=0​k​​e​j​​+Kd​T​​(e​k​​−e​k−1​​)​​ （式 2-3） 其中， kkk 为 采样序号，k = 0,1,2,...； uku_ku​k​​ 为第 k 次采样时刻的计算机输出值； eke_ke​k​​ 为第 k 次采样时刻输入的偏差值； ek−1e_{k-1}e​k−1​​ 为第 k-1 次采样时刻输入的偏差值； KiKiKi 为积分系数，Ki=kp∗TTiKi=kp*\\frac{T}{Ti}Ki=kp∗​Ti​​T​​； KdKdKd 为微分系数，Kd=Kp∗TdTKd=Kp*\\frac{Td}{T}Kd=Kp∗​T​​Td​​。 如果采样周期足够小，则 （式 2-2）或（式 2-3）的近似计算可以获得足够精确的结果，离散控制过程与连续过程十分接近。 （式 2－2）或（式 2－3） 表示的控制算法式直接按（式 1 －2） 所给出的 PID 控制规律定义进行计算的，所以它给出了全部控制量的大小，因此被称为全量式或位置式 PID 控制算法。 这种算法的缺点是：由于全量输出，所以每次输出均与过去状态有关，计算时要对 eke_ke​k​​ 进行累加，工作量大。并且，因为计算机输出的对应的是执行机构的实际位置，如果计算机出现故障，输出的将大幅度变化，会引起执行机构的大幅度变化，有可能因此造成严重的生产事故，这在实际生产际中是不允许的。 增量式 PID 算法 所谓增量式 PID 是指数字控制器的输出只是控制量的增量 △uk\\bigtriangleup u_k△u​k​​ 。 当执行机构需要的控制量是增量，而不是位置量的绝对数值时，可以使用增量式 PID 控制算法进行控制。 增量式 PID 控制算法可以通过（式 2－2）推导出。由（式 2－2）可以得到控制器的第 k－1 个采样时刻的输出值为： u(k−1)=Kp[e(k−1)+(T)Ti∑j=0k−1ej+Td(e(k−1)−e(k−2))T] u_(k-1) = Kp[e_(k-1)+\\frac{(T)}{Ti}\\sum_{j=0}^{k-1}e_j+Td\\frac{(e_(k-1)-e_(k-2))}{T}]u​(​​k−1)=Kp[e​(​​k−1)+​Ti​​(T)​​∑​j=0​k−1​​e​j​​+Td​T​​(e​(​​k−1)−e​(​​k−2))​​] （式 2-4） 用（式 2-2）减去（式 2-4）相减并整理，就可以得到增量式 PID 控制算法公式： △uk=uk−uk−1=Kp[ek−ek−1+(T)Tiek+Tdek−2ek−1+ek−2T] \\bigtriangleup u_k = u_k - u_{k-1} = Kp[e_k-e_{k-1}+\\frac{(T)}{Ti}e_k+Td\\frac{e_k-2e_{k-1}+e_{k-2}}{T}]△u​k​​=u​k​​−u​k−1​​=Kp[e​k​​−e​k−1​​+​Ti​​(T)​​e​k​​+Td​T​​e​k​​−2e​k−1​​+e​k−2​​​​] =Kp(1+TTi+TdT)ek−Kp(1+2TdT)ek−1+KpTdTek−2= Kp(1+\\frac{T}{T_i}+\\frac{Td}{T})e_k - Kp(1+\\frac{2Td}{T})e_{k-1}+Kp\\frac{Td}{T}e_{k-2}=Kp(1+​T​i​​​​T​​+​T​​Td​​)e​k​​−Kp(1+​T​​2Td​​)e​k−1​​+Kp​T​​Td​​e​k−2​​ （式 2-5） =Aek+Bek−1+Cek−2=Ae_k+Be_{k-1}+Ce_{k-2}=Ae​k​​+Be​k−1​​+Ce​k−2​​ 其中， A=Kp(1+TTi+TdT)A=Kp(1+\\frac{T}{T_i}+\\frac{Td}{T})A=Kp(1+​T​i​​​​T​​+​T​​Td​​)； B=Kp(1+2TdT)B=Kp(1+\\frac{2Td}{T})B=Kp(1+​T​​2Td​​)； C=KpTdTC=Kp\\frac{Td}{T}C=Kp​T​​Td​​。 由（式 2－5）可以看出，如果计算机控制系统采用恒定的采样周期 T ，一旦确定 A、 B、 C，只要使用前后三次测量的偏差值，就可以由（式 2－5）求出控制量。 增量式 PID 控制算法与位置式 PID 算法（式 2－2）相比，计算量小的多，因此在实际中得到广泛的应用。 而位置式 PID 控制算法也可以通过增量式控制算法推出递推计算公式： uk=uk−1+△uku_k=u_{k-1}+\\bigtriangleup u_ku​k​​=u​k−1​​+△u​k​​ （式 2-6） （式 2-6）就是目前在计算机控制中广泛应用的数字递推 PID 控制算法。 采样周期的选择 香农（Shannon） 采样定律 ：为不失真地复现信号的变化， 采样频率至少应大于或等于连续信号最高频率分量的二倍。根据采样定律可以确定采样周期的上限值。实际采样周期的选择还要受到多方面因素的影响，不同的系统采样周期应根据具体情况来选择。 采样周期的选择，通常按照过程特性与干扰大小适当来选取采样周期：即对于响应快、（如流量、压力） 波动大、易受干扰的过程，应选取较短的采样周期；反之，当过程响应慢（如温度、 成份）、滞后大时，可选取较长的采样周期。 采样周期的选取应与 PID 参数的整定进行综合考虑， 采样周期应远小于过程的扰动信号的周期，在执行器的响应速度比较慢时，过小的采样周期将失去意义，因此可适当选大一点；在计算机运算速度允许的条件下，采样周期短， 则控制品质好；当过程的纯滞后时间较长时， 一般选取采样周期为纯滞后时间的 1/4～1/8。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A28.html":{"url":"A28.html","title":"电机速度闭环内环PID控制","keywords":"","body":"电机速度闭环内环PID控制 本小节教你使用增量式 PID 算法，对带编码器的直流减速电机进行速度闭环内环控制。 闭环控制 闭环控制，即通过反馈环节，测量被控制对象的变化，用以修正电机输出的控制技术。 对于要求不高的应用，通常采用简单的开环控制。例如，给直流有刷电机的两根引线通电，电机就会旋转；施加的电压越高，电机转速越高，力量越大。但是在很多需要精密控制的场合，仅仅这种方式还是不够的，还需要依靠一定的反馈装置，将电机的转速或位置信息反馈给微控制器或其他的机械装置，通过一定的算法变成可以调节电机控制信号的输出，从而使电机的实际转速、位置等参数与我们所希望的一致。机器人控制是一个精度要求比较高的领域，例如，基于以下的一些考虑，机器人平台需要使用闭环控制。 开环控制情况下，移动机器人在爬坡时，电机速度会下降。更糟糕的是，当双轴独立驱动的移动机器人以一定的角度接近斜坡时。每一个车轮转速的下降值将会不同，结果是机器人的实际运动轨迹是沿着一条曲线而不是直线行进。 不平坦的地面会造成移动机器人的两个车轮转速之间的差异。如果转速较低的车轮的驱动电机没有得到相应的电压补给，移动机器人将偏移既定的路线。 由于安装工艺、负载不完全均衡等原因，即使是完全匹配的两个电机，并在相同的输入电压条件下，他们的速度有时仍会产生不同，即转速差。 如果采用的是 PWM 控制，即使在 PWM 信号占空比不变的条件下，随着电池电压的逐渐下降，电机供给电压也会随之降低，从而导致电机的转速与给定值不完全一致。 综合以上的一些考虑，必须选择闭环控制的方式，其工作流程如下图所示：闭环系统中加上了反馈环节（通常机器人的驱动电机使用的是增量式编码器）。在闭环控制系统中，速度指令值通过微控制器变换到功放驱动电路，功放驱动电路再为电机提供能量。编码器用于测量车轮速度的实际值并将其回馈给微控制器。基于实际转速与给定转速的差值，即“偏差”，驱动器按照一定的计算方法（如 PID 算法）调整相应的电压供给，如此反复，直到达到给定转速。 M 法测速原理 在《Timer编码器模式读取编码器》一节中，我们已经用到 M 法测速，但并未对其原理作讲解。M 法测速原理其实很简单，就是数固定时间段内的脉冲数，再用脉冲数除于时间得到速度。脉冲数是速度的一个表征量，用固定时间段内累计的脉冲数除于该固定时间，就可以求得该固定时间段的平均速度。固定时间段的时间越短，所求得的速度就越接近瞬时速度。 我们的电机上装有霍尔编码器，编码器的码盘跟电机转子同轴安装，电机转动时，码盘也随轴同转，并且转一圈会输出一定数量的脉冲。M 法是数固定时间内产生的脉冲数，在实际工程中比较好实现。而 T 法是数两个脉冲间隔的时间，T 法测速在实际工程中比较少用。 速度闭环 PID 控制 以下内容使用到上位机——虚拟示波器，其具体移植、使用方法已经在《MPU6050姿态解算和数据融合》一节中进行说明，本节不再具体讲解其移植方法，请萌新们自行温习之前的章节，按部就班来学习。 速度闭环 PID 控制，就是用速度测量值与目标值进行作差，得到控制偏差，然后通过对偏差的 PID 控制，使偏差趋向于零。 进入我们上修改过的 MiaowLabs-Demo 文件夹，再打开里面的 MDK-ARM 文件夹，找到 MiaowLabs-Demo.uvprojx 工程文件，双击，打开工程。在 MDK-ARM 工程界面，在左侧 Project 栏目下的 Application/User 文件夹里找到 control.c 源文件，双击打开该文件。 添加以下变量： unsigned int g_nLeftMotorPulse;//全局变量，保存左电机脉冲数值 int g_nSpeedTarget = 0;//全局变量，速度目标值 int g_nLeftMotorOutput;//左电机输出 int nErrorPrev;//上一次偏差值 int nPwmBais,nPwm;//PWM增量，PWM总量 Image 5.15.1 - 添加变量代码 添加以下函数： void GetMotorPulse(void)//读取电机脉冲 { g_nLeftMotorPulse = (short)(__HAL_TIM_GET_COUNTER(&htim4));//获取计数器值 __HAL_TIM_SET_COUNTER(&htim4,0);//计数器清零 } int SpeedInnerControl(int nPulse,int nTarget)//速度内环控制 { int nError;//偏差 float fP = 10.0, fI = 0.9;//这里只用到PI，参数由电机的种类和负载决定 nError = nPulse - nTarget;//偏差 = 目标速度 - 实际速度 nPwmBais = fP * (nError - nErrorPrev) + fI * nError;//增量式PI控制器 nErrorPrev = nError;//保存上一次偏差 nPwm += nPwmBais;//增量输出 if(nPwm > 100) nPwm = 100;//限制上限，防止超出PWM量程 if(nPwm Image 5.15.2 - 添加函数代码 在 control.h 头文件中，声明全局变量和相关函数： #ifndef __CONTROL_H #define __CONTROL_H #include \"filter.h\" extern unsigned char g_ucMainEventCount; extern float g_fCarAngle; extern unsigned int g_nLeftMotorPulse; extern int g_nSpeedTarget; extern int g_nLeftMotorOutput; void GetMpuData(void); void AngleCalculate(void); void GetMotorPulse(void); int SpeedInnerControl(int nPulse,int nTarget); void SetMotorVoltageAndDirection(int nMotorPwm); #endif Image 5.15.3 - 代码截图 在 MDK-ARM 左侧 Application/User 文件夹中，找到 stm32f1xx_it.c 源文件，双击打开，将以下代码敲入 SysTick_Handler() 函数中： /* USER CODE BEGIN SysTick_IRQn 0 */ g_ucMainEventCount++; if(g_ucMainEventCount>=5)//SysTick是1ms一次，这里判断语句大于5就是5ms运行一次 { g_ucMainEventCount=0; GetMotorPulse(); }else if(g_ucMainEventCount==1) { g_nLeftMotorOutput = SpeedInnerControl(g_nLeftMotorPulse,g_nSpeedTarget); }else if(g_ucMainEventCount==2) { SetMotorVoltageAndDirection(g_nLeftMotorOutput); } ButtonScan(); /* USER CODE END SysTick_IRQn 0 */ Image 5.15.4 - 代码截图 这段代码的意思是，每 5ms 对电机进行一次控制，依次读取脉冲，进行速度内环控制，设置电机电压和方向。 有些好奇萌在这里会产生困惑：为什么中断服务函数里的代码写法这么奇怪？为什么要每 1ms 单独运行一部分代码？既然要 5ms 运行一次代码，那么我直接把中断时间改成 5ms，然后在 5ms 中断里运行全部代码不更简单吗？对，你的理解是对的。按你所想的来做也是正确的。但是，因为我们这里使用的是滴答定时器 SysTick，默认就是 1ms 运行一次，而且 HAL 库里面的延时函数 HAL_Delay() 也是以滴答定时器 SysTick 为基准获得延时的时间，如果我们把 SysTick 改成了 5ms，那么还需要改动 HAL 库中的相关函数代码，更加麻烦。 在 main.c 文件中，加入初始化代码和主循环代码。 HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);//开启TIM4的编码器接口模式 HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_2);//开启TIM3_CH2的PWM输出 HAL_GPIO_WritePin(BIN1_GPIO_Port, BIN1_Pin, GPIO_PIN_SET);//初始化BIN1引脚为低电平 HAL_GPIO_WritePin(BIN2_GPIO_Port, BIN2_Pin, GPIO_PIN_RESET);//初始化BIN2引脚为高电平 初始化代码主要是开启 TIM4 的编码器接口模式，和 TIM3_CH2 通道的 PWM 输出，还有 BIN1 和 BIN2 对应的控制引脚的电平初始化。 if(g_iButtonState == 1) { g_nSpeedTarget +=10; HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin); HAL_Delay(10); //OutPut_Data();//调用虚拟示波器的发送函数 } OutPut_Data();//调用虚拟示波器的发送函数 Image 5.15.5 - 代码截图 主循环代码，主要是用到了用户按钮，当用户按钮按下时，速度目标值增加 10，LED 指示灯电平翻转。另外，虚拟示波器的发送函数也放在主循环中，避免影响到中断任务的运行。使用虚拟示波器方便观察电机的速度实际值和速度预期值的联系。 留意 SpeedInnerControl() 函数，在这里我们对虚拟示波器的数组进行了重新赋值，不再是上个实验中的加速度、陀螺仪和角度值，而是速度实际值、目标值、PWM 输出值。 int SpeedInnerControl(int nPulse,int nTarget)//速度内环控制 { int nError;//偏差 float fP = 10.0, fI = 0.9;//这里只用到PI，参数由电机的种类和负载决定 nError = nPulse - nTarget;//偏差 = 目标速度 - 实际速度 nPwmBais = fP * (nError - nErrorPrev) + fI * nError;//增量式PI控制器 nErrorPrev = nError;//保存上一次偏差 nPwm += nPwmBais;//增量输出 if(nPwm > 100) nPwm = 100;//限制上限，防止超出PWM量程 if(nPwm 到这里，我们就完成了电机速度闭环内环控制的代码框架搭建。在 SpeedInnerControl() 函数中，里面有两个变量 fP、fI，电机速度闭环的关键点就在于通过整定 fP、fI 参数，使电机能够快速、稳定地达到预设的期望速度。 编译代码，将代码烧录到小车。小车的电机应该组装好，并用充电器垫在小车的电池盒下方，便于观察轮子转动情况。打开虚拟示波器，通过相应曲线可以更快速地整定参数。 所有测试都是在空载， PWM 载波为 10KHz 的情况下进行。 取 fP = 0，fI = 0.1 时，响应曲线如下： Image 5.15.6 - 响应曲线 其中红线代表电机实际速度，黄线代表电机期望速度。每隔一段时间，按下核心板上的用户按钮，给予电机一个阶跃信号。我们可以看到，此时红线不能很快速地跟随黄色线，并且两条线段稳定时，红线跟黄线之间始终有个误差。这就表明 fI = 0.1 过小了，我们可以继续增加该数值看看效果。 取 fP = 0，fI = 0.9 时，响应曲线如下： Image 5.15.7 - 响应曲线 可以看到，这时红线能够很及时地跟踪到黄线，但是出现了震荡。有没有办法能够消除震荡呢？ 取 fP = 2.0，fI = 0.9 时，响应曲线如下： Image 5.15.8 - 响应曲线 这时，可以看到红线的震荡已经没有那么明显了，控制效果明显好了很多。这表明 fP = 2.0 是能够抑制震荡的，我们可以继续增大该数值看看效果。 取 fP = 10.0，fI = 0.9 时，响应曲线如下： Image 5.15.9 - 响应曲线 这时，可以看到红线能够及时地跟踪到黄线，并且没有发生震荡，很接近我们想要的效果。 当 fP = 10.0，fI = 0.9 时，电机速度闭环内环控制已经取得了不错的效果，但是这不是最好的效果，还可以在这组参数附近进行微调，但需要投入一定的时间。由于篇幅有限，这里不再微调，如果读者感兴趣，可以自行进行微调，以获得更好的控制效果。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"E02.html":{"url":"E02.html","title":"直立平衡角度环PID控制","keywords":"","body":"直立平衡角度环PID控制 本小节主要教你编写角度环 PID 控制相关的代码和对 PID 参数进行整定。 补充相关初始化代码 为了降低学习难度，便于萌新们学习，在编码器和驱动电机的例程中，我们以一个电机为例，进行了具体的操作设置。但是，两轮自平衡小车是有两个电机的，所以，在进行直立平衡角度环 PID 控制之前，我们需要先对另一个电机相关的还没初始化的相关引脚进行初始化。 在《PWM与TB6612FNG驱动电机》一节中，我们配置了一个电机的相关控制引脚（TIM3_CH2、PA3、PA4），在这里对另一个电机的相关控制引脚（TIM3_CH1、PB0、PB1）。 回到 STM32CubeMX 软件界面，在左侧 Pinout&Configuration 界面中的 Timers 下拉中点击 TIM3，然后在 TIM3 Mode and Configuration 的 Mode 中将 Channel1 选择为 PWM Generation CH1。因为我们之前配置 Channel2 的时候，已经对参数设置选项卡做出了对应的修改，这时就不用再修改了。 Image 5.16.1 - 配置 TIM3 PWM Channel2 回到 STM32CubeMX 软件界面，在右侧界面的芯片中分别点击 PB0、PB1，并将其配置为 GPIO_Output。在 System Core 下拉菜单中选择 GPIO，然后在左侧的 System Core 下拉菜单中选择 GPIO，然后在 GPIO Mode and Configuration 中对 PA3、PA4 引脚进行配置，GPIO output level 代表 GPIO 默认输出电平，在这里设置为低电平；GPIO mode 代表 GPIO 引脚模式，在这里设置为推挽输出；GPIO Pull-up/Pull-down 即 GPIO 上拉或下拉，在这里设置为既不上拉也不下拉；Maximum output speed 即 最大输出速度，在这里设置为低速；User Label 即用户标签，在这里将 PA0 改为 AIN1，PB1 改为 AIN2。 Image 5.16.2 - 配置 GPIO PB0 和 PB1 引脚 在《Timer编码器模式读取编码器》一节中，我们只配置 TIM4 为编码器模式，没有配置 TIM2。在这里对 TIM2 进行补充配置，其实很简单，跟之前配置 TIM4 一样的。 进入我们上一小节修改过的 MiaowLabs-Demo 文件夹，找到 MiaowLabs-Demo.ioc 工程文件，双击，打开工程。在左侧 Pinout&Configuration 界面中的 Timers 下拉中点击 TIM2，然后在 TIM2 Mode and Configuration 的 Mode 中将 Combined Channels 选择为 Encoder Mode，即编码器模式。 在 Configuration 中选择 Parameter Setting 选项卡，进行基本参数配置。其中，Counter Mode 默认为 Up，即向上计数。Counter Period 设置为 65535，即计数器周期，这是一个 16 位的自动加载寄存器，填写范围为 0~65535。Encoder Mode 设置为 Encoder Mode TI1 and TI2，即两个输入 TI1 和 TI2 都被用来作为增量编码器的接口。Polarity 默认为 Rising Edge，即为捕获上升沿。其他参数默认即可。 Image 5.16.3 - 配置 TIM2 点击 GENERATE CODE，重新生成代码。 Image 5.16.4 - 重新生成代码 打开 MDK-ARM 工程，左侧 Application/User main.c 源文件的 main 函数里的 GPIO 初始化函数： MX_GPIO_Init();，可以看到里面新增了我们刚才添加的 AIN1 和 AIN2 引脚。 点开 TIM3 初始化函数 MX_TIM3_Init();，能看到里面 Channel1 和 Channel2 的相关代码都已经有了。 至此，STM32CubeMX 软件部分的初始化配置就完成了，接下来，要修改我们之前定义的算法代码。 角度环PID控制 在 control.c 文件中里敲下以下代码： #include \"control.h\" #include \"filter.h\" #include \"mpu6050.h\" #include \"math.h\" #include \"outputdata.h\" #include \"tim.h\" #include \"main.h\" #define MOTOR_OUT_DEAD_VAL 0 //死区值 #define MOTOR_OUT_MAX 100 //占空比正最大值 #define MOTOR_OUT_MIN (-100) //占空比负最大值 #define CAR_ANGLE_SET 0//目标角度 #define CAR_ANGLE_SPEED_SET 0//目标角速度 short x_nAcc,y_nAcc,z_nAcc;//加速度x轴、y轴、z轴数据 short x_nGyro,y_nGyro,z_nGyro;//陀螺仪x轴、y轴、z轴数据 float x_fAcc,y_fAcc,z_fAcc;//用于存储加速度x轴、y轴、z轴数据运算后的数据 float g_fAccAngle;//加速度传感器经过atan2()解算得到的角度 float g_fGyroAngleSpeed;//陀螺仪角速度 float g_fCarAngle;//小车倾角 float dt = 0.005;//互补滤波器控制周期 unsigned int g_nMainEventCount;//主事件计数，用在中断中 unsigned int g_nGetPulseCount;//捕获脉冲计数，用在中断中 unsigned int g_nLeftMotorPulse,g_nRightMotorPulse;//全局变量，保存左电机脉冲数值 int nPwmBais;//PWM增量 int nLeftMotorPwm,nRightMotorPwm;//左电机PWM输出总量，左电机PWM输出总量 int nLeftMotorErrorPrev,nRightMotorErrorPrev;//左电机上一次偏差，右电机上一次偏差 float g_fLeftMotorOut,g_fRightMotorOut; float g_fAngleControlOut; void GetMpuData(void)//读取MPU-6050数据 { MPU_Get_Accelerometer(&x_nAcc,&y_nAcc,&z_nAcc);//获取MPU6050加速度数据 MPU_Get_Gyroscope(&x_nGyro,&y_nGyro,&z_nGyro); //获取MPU6050陀螺仪数据 } void AngleCalculate(void)//角度计算 { //-------加速度数据处理-------------------------- //量程为±2g时，灵敏度：16384 LSB/g x_fAcc = x_nAcc / 16384.0; y_fAcc = y_nAcc / 16384.0; z_fAcc = z_nAcc / 16384.0; g_fAccAngle = atan2(y_fAcc,z_fAcc) * 180.0 / 3.14; //-------陀螺仪数据处理------------------------- //范围为2000deg/s时，换算关系：16.4 LSB/(deg/s) g_fGyroAngleSpeed = x_nGyro / 16.4; //计算角速度值 //-------互补滤波--------------- g_fCarAngle = ComplementaryFilter(g_fAccAngle, g_fGyroAngleSpeed, dt); OutData[0]=g_fAccAngle;//发送加速度初步计算的角度 OutData[1]=g_fGyroAngleSpeed;//发送陀螺仪角速度 OutData[2]=g_fCarAngle;//发送数据融合得到的角度 } void GetMotorPulse(void)//读取电机脉冲 { g_nLeftMotorPulse = (short)(__HAL_TIM_GET_COUNTER(&htim4));//获取计数器值 __HAL_TIM_SET_COUNTER(&htim4,0);//TIM4计数器清零 g_nRightMotorPulse = (short)(__HAL_TIM_GET_COUNTER(&htim2));//获取计数器值 __HAL_TIM_SET_COUNTER(&htim2,0);//TIM2计数器清零 } int SpeedInnerControl(int nPulse, int nTarget, int nPwm, int nErrorPrev)//速度内环控制 { int nError;//偏差 float fP = 10.0, fI = 0.9;//这里只用到PI，参数由电机的种类和负载决定 nError = nPulse - nTarget;//偏差 = 目标速度 - 实际速度 nPwmBais = fP * (nError - nErrorPrev) + fI * nError;//增量式PI控制器 nErrorPrev = nError;//保存上一次偏差 nPwm += nPwmBais;//增量输出 if(nPwm > 100) nPwm = 100;//输出饱和处理，限制上限，防止超出PWM量程 if(nPwm 0) g_fLeftMotorOut += MOTOR_OUT_DEAD_VAL; else if((int)g_fLeftMotorOut0) g_fRightMotorOut += MOTOR_OUT_DEAD_VAL; else if((int)g_fRightMotorOut MOTOR_OUT_MAX) g_fLeftMotorOut = MOTOR_OUT_MAX; if((int)g_fLeftMotorOut MOTOR_OUT_MAX) g_fRightMotorOut = MOTOR_OUT_MAX; if((int)g_fRightMotorOut 因为角度环 PID 控制已经涉及到使用两轮自平衡小车的两个电机，所以在本次实验的大部分函数跟上一个实验不太一样，需要改成适用于两个电机。 在 control.h 中声明函数和变量，敲入以下代码： #ifndef __CONTROL_H #define __CONTROL_H #include \"filter.h\" extern unsigned int g_nMainEventCount;//主事件计数，用在中断中 extern unsigned int g_nGetPulseCount;//捕获脉冲计数，用在中断中 extern float g_fCarAngle; extern unsigned int g_nLeftMotorPulse; extern int g_nSpeedTarget; extern int g_nLeftMotorOutput; void GetMpuData(void); void AngleCalculate(void); void GetMotorPulse(void); int SpeedInnerControl(int nPulse, int nTarget, int nPwm, int nErrorPrev); void SetMotorVoltageAndDirection(int nLeftMotorPwm,int nRightMotorPwm); void MotorOutput(void); void AngleControl(void); #endif 在 stm32f1xx_it.c 中的 SysTick 中断服务函数中，即滴答中断服务函数中，敲入以下代码： void SysTick_Handler(void) { /* USER CODE BEGIN SysTick_IRQn 0 */ g_nMainEventCount++;//每进一次中断，主事件函数自动加1 if(g_nMainEventCount>=5)//SysTick是1ms一次，这里判断语句大于5就是5ms运行一次 { g_nMainEventCount=0;//主事件循环每5ms循环一次，这里清零，重新计时。 GetMotorPulse();//每5ms捕获一次脉冲 }else if(g_nMainEventCount==1){//这1ms时间片段获取数据和角度计算 GetMpuData();//获取MPU-6050数据 AngleCalculate(); //进行角度计算 }else if(g_nMainEventCount==2){ AngleControl(); //这1ms时间片段进行角度控制 }else if(g_nMainEventCount==3){ //这1ms时间片段暂时啥都不干 }else if(g_nMainEventCount==4){ MotorOutput(); //电机输出函数，每5ms执行一次 } ButtonScan(); /* USER CODE END SysTick_IRQn 0 */ HAL_IncTick(); /* USER CODE BEGIN SysTick_IRQn 1 */ /* USER CODE END SysTick_IRQn 1 */ } 上个实验中，我说过 SysTick 定时器在 STM32CubeMX 中被用于 HAL 库的延时，默认是每 1ms 中断一次。我们想要每 5ms 进行完一次全部控制，我们可以定义一个 5ms 的定时中断，比如使用 Timer1（定时器1）。这是可取的方法。但由于在这里，Timer2 和 Timer4 已经配置成编码器模式，Timer3 已经配置成 PWM 输出模式，只剩下 Timer1 和 SysTick 定时器可以用了。我们后续还想继续扩展，比如扩展超声波避障，那么还需要用到定时器，得预留一路定时器备用，于是这里，我们决定预留 Timer1，使用 SysTick 定时器。 可是，偏偏 SysTick 定时器又是 1ms 就中断一次，我们可不想对其进行改动，比如设置成 5ms 中断一次，一旦改动了延时函数啥得又得跟着改了，多麻烦？有没有省心一点的办法？肯定有啦，聪明的你可能也会想到，只要将本来 5ms 内要运行的代码，分成 5 次，每次在 1ms 内运行完也是一样的效果。我们利用一个计数变量 g_nMainEventCount，然后进行计数，将代码分割好，分别放在每个 1ms 内执行，这样就大功告成啦。我们也正是这样干了，取得很好的执行效果。 另外，捕获脉冲函数 GetMotorPulse() 是 5ms 执行一次，因为如果执行得太快，比如 1ms 执行一次，能捕获到的脉冲数比较少，这样误差会比较大，所以这个执行时间要适当。 在 main.c 源文件中加入以下初始化代码： /* USER CODE BEGIN 2 */ if(!MPU_Init())//如果MPU6050初始化成功，返回0，!0则为1 { printf(\"MPU-6050 Init Successfully\");//成功了则打印 MPU-6050 Init Successfully } HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);//开启TIM4的编码器接口模式 HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);//开启TIM2的编码器接口模式 HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_1);//开启TIM3_CH1的PWM输出 HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_2);//开启TIM3_CH2的PWM输出 /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { //printf(\"小车角度 = %f\",g_fCarAngle); //HAL_Delay(500);//延时0.5s，防止打印发送数据太快 //HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin); if(g_iButtonState == 1) { //g_nSpeedTarget +=10; HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin); HAL_Delay(10); //OutPut_Data();//调用虚拟示波器的发送函数 } //OutPut_Data();//调用虚拟示波器的发送函数 } 主要就是开启定时器的编码器接口模式和 PWM 输出，STM32CubeMX 软件只是负责配置和生成相关底层代码，但是要我们开启才能使用。并且，在主循环中，把一些无关的代码，注释掉，只保留一个按键控制 LED 亮灭功能。 到这里，角度环 PID 控制的框架已经搭建好了。接下来，就是对 PID 参数进行调试的事情了。PID 参数一般都是先调好内环再调外环。速度闭环内环作为内环，是直接对接电机的一环，其 PID 参数在上一个实验已经取得一组不错的参数，我们可以直接使用。本实验最重要的，是对角度环 PID 参数进行调试，要取得一组良好效果的参数。 让我们看看角度环控制函数 AngleControl() ： void AngleControl(void) //角度环控制函数 { float fP = 5.0;//角度环P参数 float fD = 0.2;//角度环D参数 g_fAngleControlOut = (CAR_ANGLE_SET - g_fCarAngle) * fP + (CAR_ANGLE_SPEED_SET - g_fGyroAngleSpeed) * fD;//PD控制器 } 先简单说明下角度环控制函数AgnleControl（）里面用到的变量： g_fCarAngle：小车角度； g_fGyroAngleSpeed：小车角速度，其实就是陀螺仪数值； CAR_ANGLE_SET：小车期望角度值，也是机械中值，宏定义，在里面可以看到设定为 0，因为我们的小车的重心分布在小车的轮轴之上，而且期望小车保持直立，随时保持为角度为 0 的状态。如果小车的重心不是在车轴上，而是偏向一边，那么要减去个偏差的值。 *CAR_ANGLE_SPEED_SET：小车期角速度值，宏定义，在这里可以看到设定为0，因为我们期望小车保持直立，随时保持为角速度为 0 的状态。 PD 控制器比较简洁明了，就一句话，我们通过 PD 控制器计算直立控制 PWM。 需要说明的是，在两轮自平衡小车的直立平衡控制环节中，选择 PD 控制而非 PID 控制的原因在于： 两轮自平衡小车的姿态检测信号中不可避免地存在噪声信号，这些噪声信号经过积分I环节会随着时间不断地累积，从而导致积分器失去消除静差的调节功能并产生控制误差； 两轮自平衡小车的轮胎与地面的摩擦会产生阻尼作用，这种阻尼可以克服小车姿态倾角静差的持续增加。 确定 fP 值的极性（令 fD=0） 首先我们估计 fP 的取值范围。我们的 PWM 量程设置的为 0~100，0 代表占空比 0%，100 代表占空比 100%。假如我们设定 fP 值为 25，那么两轮自平衡小车在 ±4° 的时候就会输出 100% 占空比，即电机全力满转。根据我们的感性认识，这显然太大了，那我们就可以估计 fP 值在 0~25 之间，首先大概我们给一个值 fP=-5，我们可以观察到，小车往哪边倒，电机会往另一边加速转动，导致小车倒下得更快，就是一个我们不愿看到的正反馈的效果，说明 fP 值的极性反了。接下来我们设定 fP=5,这个时候可以看到两轮自平衡小车有直立的趋势，虽然响应太慢，但是，我们可以确定 fP 值极性是正的。具体的数据接下来再仔细调试。 确定 fP 值的大小（令 fD=0，请结合本小节开头的直立控制函数理解） 确定参数的原则是： fP 一直增加，直到出现大幅度的低频摆动。 设定 fP=1，这个时候我们可以看到，小车虽然有平衡的趋势，但是显然响应太慢了。 设定 fP=2，这个时候我们可以看到，小车虽然有平衡的趋势，而且响应有所加快，但是响应还是不足以让小车保持平衡。 设定 fP=5，这个时候我们可以看到，小车的响应明显加快，而且来回推动小车的时候，会有大幅度的低频摆动。说明这个时候 kp 值已经足够大了，需要增加微分控制削弱 P 控制，抑制低频摆动。 确定 kd 值的极性（令 kp=0） 我们得到的 MPU-6050 输出的陀螺仪的原始数据，通过观察数据，我们发现最大值不会超过 4 位数（正常应用在两轮自平衡小车上的时候），在经过单位换算（/16.4）后，数值不超过 61， 再根据100 代表占空比 100%，所以我们估算 kd 值应该在 0~1.6 之间，我们先设定 fD=-0.1，当我们拿起小车旋转的时候，车轮会反向转动，并没有能够实现跟随效果。这说明了 fD 的极性反了。接下来，我们设定 fD=0.1。这个时候我们可以看到，当我们旋转小车的时候，车轮会同向以相同的速度跟随转动，这说明我们实现了角速度闭环，至此，我们可以确定 fD 的极性是正的。 确定 fD 值的大小（令 fP=5.0，请结合本小节开头的直立控制函数理解） 确定参数的原则是： fD 一直增加，直到出现高频抖动。设定 fD=0.1,这个时候我们可以看到，低频大幅度频抖动已经基本消除。设定 fD=0.2,这个时候我们可以看到，整体性能已经非常棒。设定 fD=0.3,这个时候我们可以看到，小车开始出现高频剧烈抖动。 至此，我们可以确定得到 fP=5，fD=0.3 是 P、D 参数的临界值。然后我们进行最关键的一步，在临界值的附近进行参数微调（一般取值比临界值小）。这个时候我们可以看到，小车运行非常平稳，但是依然无法保持长时间的直立，直立很短一段时间后会往一个方向加速倒下。这个等我们下面加上速度环才能得到更好的性能。只有直立环是很难让小车达到很好的直立效果的。 至此，直立调试部分就告一段落了。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"E03.html":{"url":"E03.html","title":"运动速度闭环外环PID控制","keywords":"","body":"运动速度闭环外环PID控制 在 control.c 文件中里新增以下定义： #define CAR_SPEED_SET 0//小车目标速度 #define CAR_POSITION_MAX 200 #define CAR_POSITION_MIN (-200) float g_fCarSpeed;//小车实际速度 float g_fCarSpeedPrev;//小车前一次速度 float g_fCarPosition;//小车路程 long g_lLeftMotorPulseSigma;//左电机25ms内累计脉冲总和 long g_lRightMotorPulseSigma;//右电机25ms内累计脉冲总和 float g_fSpeedControlOut;//速度环输出 新增速度环控制函数代码： void SpeedControl(void)//速度外环控制函数 { float fP=0.6,fI=0.03; //速度环PI参数，I取0.1时，小车出现明显来回摆动。 float fDelta;//临时变量，用于存储误差 g_fCarSpeed = (g_lLeftMotorPulseSigma + g_lRightMotorPulseSigma ) / 2;//左轮和右轮的速度平均值等于小车速度 g_lLeftMotorPulseSigma = g_lRightMotorPulseSigma = 0; //全局变量，注意及时清零 g_fCarSpeed = 0.7 * g_fCarSpeedPrev + 0.3 * g_fCarSpeed ;//低通滤波，使速度更平滑 g_fCarSpeedPrev = g_fCarSpeed; //保存前一次速度 fDelta = CAR_SPEED_SET - g_fCarSpeed;//误差=目标速度-实际速度 g_fCarPosition += fDelta;//对速度误差进行积分 //设置积分上限设限 if((int)g_fCarPosition > CAR_POSITION_MAX) g_fCarPosition = CAR_POSITION_MAX; if((int)g_fCarPosition 修改电机输出函数，加入速度环控制量： void MotorOutput(void)//电机输出函数,将直立控制、速度控制、方向控制的输出量进行叠加,并加入死区常量，对输出饱和作出处理。 { g_fLeftMotorOut = g_fAngleControlOut - g_fSpeedControlOut;//这里的电机输出等于角度环控制量 + 速度环外环,这里的 - g_fSpeedControlOut 是因为速度环的极性跟角度环不一样，角度环是负反馈，速度环是正反馈 g_fRightMotorOut = g_fAngleControlOut - g_fSpeedControlOut; /*增加电机死区常数*/ if((int)g_fLeftMotorOut>0) g_fLeftMotorOut += MOTOR_OUT_DEAD_VAL; else if((int)g_fLeftMotorOut0) g_fRightMotorOut += MOTOR_OUT_DEAD_VAL; else if((int)g_fRightMotorOut MOTOR_OUT_MAX) g_fLeftMotorOut = MOTOR_OUT_MAX; if((int)g_fLeftMotorOut MOTOR_OUT_MAX) g_fRightMotorOut = MOTOR_OUT_MAX; if((int)g_fRightMotorOut 修改 GetMotorPulse() 读取电机脉冲函数，修正两个电机脉冲数据的极性，添加速度外环相关代码： void GetMotorPulse(void)//读取电机脉冲 { g_nRightMotorPulse = (short)(__HAL_TIM_GET_COUNTER(&htim4));//获取计数器值 g_nRightMotorPulse = (-g_nRightMotorPulse); __HAL_TIM_SET_COUNTER(&htim4,0);//TIM4计数器清零 g_nLeftMotorPulse = (short)(__HAL_TIM_GET_COUNTER(&htim2));//获取计数器值 __HAL_TIM_SET_COUNTER(&htim2,0);//TIM2计数器清零 g_lLeftMotorPulseSigma += g_nLeftMotorPulse;//速度外环使用的脉冲累积 g_lRightMotorPulseSigma += g_nRightMotorPulse;//速度外环使用的脉冲累积 } 注意上面的代码，增加了一句 g_nRightMotorPulse = (-g_nRightMotorPulse);，这是因为两个电机装在两轮自平衡小车是相对安装，当小车前进时，一个电机的转动方向是另一个电机的反方向，这时读取到的编码器数据，一个是正数，另一个是负数，而负号代表反转。所以，在这里我们要在软件上修正两个编码器数据，我们定义两轮自平衡小车往一个方向运动为正方向，编码器为正数，我们在此将那个编码器为负数的数据取反，拨反为正。 g_lLeftMotorPulseSigma += g_nLeftMotorPulse;//速度外环使用的脉冲累积 g_lRightMotorPulseSigma += g_nRightMotorPulse;//速度外环使用的脉冲累积 而上面这两句代码，是因为速度外环的控制频率是比角度环低的，等下看到中断代码，会看到速度环的控制频率是 40Hz（25ms），而角度环的控制频率是 200Hz（5ms）。而 GetMotorPulse() 读取电机脉冲函数是每 5ms 读取一次脉冲，这里两句代码将 5 次 5ms 的脉冲累计起来。 在 control.h 头文件中加入代码： extern unsigned int g_nSpeedControlCount; 声明外部用到的变量。 void SpeedControl(void); 声明变量，等下中断里要调用。 在 stm32fxx_it.c 中更新以下代码： void SysTick_Handler(void) { /* USER CODE BEGIN SysTick_IRQn 0 */ g_nMainEventCount++;//每进一次中断，主事件函数自动加1 if(g_nMainEventCount>=5)//SysTick是1ms一次，这里判断语句大于5就是5ms运行一次 { g_nMainEventCount=0;//主事件循环每5ms循环一次，这里清零，重新计时。 GetMotorPulse(); //每5ms捕获一次脉冲 }else if(g_nMainEventCount==1){//这1ms时间片段获取数据和角度计算 GetMpuData();//获取MPU-6050数据 AngleCalculate(); //进行角度计算 }else if(g_nMainEventCount==2){ AngleControl(); //这1ms时间片段进行角度控制 }else if(g_nMainEventCount==3){ g_nSpeedControlCount++; if(g_nSpeedControlCount >= 5) { SpeedControl(); //速度控制，25ms进行一次 g_nSpeedControlCount=0; //清零 } }else if(g_nMainEventCount==4){ MotorOutput(); //电机输出函数，每5ms执行一次 } ButtonScan(); /* USER CODE END SysTick_IRQn 0 */ HAL_IncTick(); /* USER CODE BEGIN SysTick_IRQn 1 */ /* USER CODE END SysTick_IRQn 1 */ } 主要是在第 3 个 1ms 时间片段里增加了速度控制代码 SpeedControl();。值得注意的是，我们在这里用了一个计数变量 g_nSpeedControlCount 在时间片段里进行计数，要知道，每个 1ms 时间片段是每 5ms 才运行一次，我们设置 g_nSpeedControlCount >= 5 就运行速度控制，并且清零，这就是 5*5=25ms 才进行一次速度控制。 为什么设置 25ms 才进行一次速度控制，而不是更大或更小的数值？这个值太大会降低速度环控制频率，太小会导致速度的误差大，所以要适中，25ms 是一个实验数值，经过多次实验验证该数值的效果好，所以采用 25ms。 确定 fP 与 fI 值的极性 另外要说明的是，虽然这里的PI控制器是速度控制常用的一种控制器，但是和普通的调速系统不一样，这里的速度控制是正反馈的， 当小车以一定的速度运行的时候，我们要让小车停下来，小车需要行驶更快的速度去“追”，小车运行的速度越快，去“追”的速度也就越快，所以这是一个正反馈的效果。如果使用常规的速度负反馈，当小车以一定的速度运行的时候，我们通过减速让小车慢下来，小车会因为惯性向前倒下。 下面介绍一种确定速度控制是正反馈还是负反馈的方法。根据之前的估计，先设定 fP=-0.1，fI=fP/20。当我们拿起小车，旋转其中一个小车轮胎的时候，根据我们设定的速度偏差 fDelta = CAR_SPEED_SET-g_fCarSpeed；另外一个车轮会反向转动，让偏差趋向于零。这就是常规的速度控制里面的负反馈，不是我们需要的效果。接下来设定 kp=0.1，ki=kp/20。此时，当我们旋转其中一个小车轮胎的时候，两个轮胎会往相同的方向加速，直至电机的最大速度，这是典型的正反馈效果，也是我们期望看到的。至此，我们可以确定 kp、ki 的符号应该是正的。 确定 fP 与 fI 的大小（开启直立控制） 下面我们进行平衡小车速度控制 fP 与 fI 值的整定，此时需要在直立环调好的基础上进行，因为我们需要结合直立环观察速度环对直立环的影响。 在调试的过程中设定速度控制的目标为零，所以，调试的理想结果应该是：小车保持平衡的同时，速度接近于零。实际上，因为小车存在比较大的转动惯量和惯性，并且齿轮减速器存在死区，很难调试到让小车完全保持静止的，我们调试两轮自平衡小车只是为了学习 PID 控制算法，所以，没有必要花太多的时间去调参数，让小车完全静止，只要能够大概实现我们需要的功能，并在这个过程对 PID 有进一步的了解即可。 先调试 fI 的大小 确定参数的原则是： fI 一直增加，直到出现大幅度的低频来回摆动。 设定 fI = 0.01，这个时候我们可以看到，小车基本没有什么改变。 设定 fI = 0.05，这个时候我们可以看到，小车好像有一点来回摆动的趋势。 设定 fI = 0.1，这个时候我们可以看到，小车已经有非常明显的大幅度来回摆动。这组参数已经过大了，我们可以得到 0.1 为临界值，我们取比 0.1 小一点的值就可以，比如 0.06。 再调试 fP 的大小 fP 一直增加，直到小车出现原地来回晃动。 设定 fP = 0.1，这个时候我们可以看到，小车基本没有什么改变。 设定 fP = 0.3，这个时候我们可以看到，小车已经没有摆动得那么厉害了，小车的速度控制的响应有所加快，但是来回摆动还是有点大，还是不足以让小车保持接近于静止的状态。。 设定 fP = 0.6，这个时候我们可以看到，已经抵消 fP 带来的来回摆动，小车已经基本没有摆动了，能在原地平衡了，而且用手推一下小车，会发现小车已经有一定的抵抗力，不会轻易就被推倒了，性能很不错。我们接下来尝试加大 fP 值看一下效果。 设定 fP = 1.2，这个时候我们可以看到，小车虽然回正力度增大了，而且响应更加快了，但是稍微加入一点的干扰都会让小车大幅度摆动，抗干扰能力明显不足，所以这个参数不可取。 微调参数 至此，我们已得到 fP=0.6，fI=0.0.05 是速度控制 P、 I 参数的可取值，但这组参数并非最优值，不只是这组参数可以让两轮自平衡小车稳定平衡，我们的电机性能比较好，可取范围比较大，用户可以自行在这组参数范围内进行微调，以获得更好的性能。 我们再来体验一下速度控制负反馈在平衡小车里面的效果，设定 fP=-0.6，fI=-0.1，这个时候我们可以看到， 小车会迅速往一个方向倒下。也就是说常规的速度负反馈在我们这边是“帮倒忙” 了！ 至此，速度控制调试部分就告一段落了。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"E10.html":{"url":"E10.html","title":"提高PWM频率为24kHz","keywords":"","body":"提高PWM频率为24kHz，控制范围为0~1000 经过上面的一系列实验下来，我们已经初步调好了两轮自平衡小车的平衡功能。但是，不知道你们有没有发现两个问题： 在小车运行时，电机会发出“滋滋滋滋”的声音，长时间听到这个声音可能会感觉到烦躁。这是因为我们之前设置的 PWM 频率为 10kHz，而人耳能感受到的振动频率范围约为20Hz~20kHz。 小车的速度环输出量如果过大，会干扰到角度环。如果速度环能比较平滑地输出，那就不会干扰到角度环，小车就能够更加稳定。 提高 PWM 频率为 24kHz 既然 10kHz 是人耳能听到的工作频率，那么我们可以尝试提高 PWM 频率来解决这个问题。 进入我们上一小节实验的 MiaowLabs-Demo 文件夹，找到 MiaowLabs-Demo.ioc 工程文件，双击，打开工程。在 Pinout&Configuration 界面中的 Timers 里点击 TIM3，在 Parameter Settings 选项卡里将 Prescaler 改成 3，Counter Period 改成 1000。此时，PWM = 72000000 / 3 / 1000 = 24000 = 24kHz。 Image 5.18.1 - 修改PWM频率 记得，先把我们文件夹里的中文和空格全部删掉，比如将 MiaowLabs-Demo - 13、提高PWM频率为24k，控制范围为0至1000 删掉中文变成 MiaowLabs-Demo再重新生成代码。不然，会提示以下错误： Image 5.18.2 - 目录下有中文和空格时会提示类似的错误 我们进入 MiaowLabs-Demo/MDK-ARM 文件夹，双击 MiaowLabs-Demo.uvprojx 文件，使用 MDK-ARM 打开工程。 我们打开 main.c 文件，在 main() 主函数中找到 MX_TIM3_Init()，右键点击 Go to Defition of \"MX_TIM3_Init();\"，转跳到该函数。 Image 5.18.3 - 转跳到该函数 可以看到 TIM3 的初始化已经重新生成我们设定的代码。 Image 5.18.4 - TIM3初始化代码已经重新生成 这样一来，我们 PWM 的可控范围不再是 0~100，而是变成了 0~1000。也就是说，当设为 PWM 设为 1000 时，占空比才是 100%。 我们之前的代码也要做出对应的改动。主要是输出上下限和 PID 参数的改动。 在 control.c 里，修改代码： #define MOTOR_OUT_MAX 1000 //占空比正最大值 #define MOTOR_OUT_MIN (-1000) //占空比负最大值 #define CAR_POSITION_MAX 900//路程（速度积分）上限 #define CAR_POSITION_MIN (-900)//路程（速度积分）下限 然后，就是重新整定 PID 参数。这里先不进行整定，接着把速度平滑输出函数加进去。 速度平滑输出 先在 control.c 中添加几个变量、宏定义： #define SPEED_CONTROL_PERIOD 25 //速度环控制周期 float g_fSpeedControlOut,g_fSpeedControlOutNew,g_fSpeedControlOutOld;//速度环输出 int g_nSpeedControlPeriod;//速度环控制周期计算量 对速度外环控制函数 SpeedControl() 进行改造，并编写速度外环平滑输出函数 SpeedControlOutput()。 void SpeedControl(void)//速度外环控制函数 { float fP=10.25,fI=0.108; //速度环PI参数， float fDelta;//临时变量，用于存储误差 g_fCarSpeed = (g_lLeftMotorPulseSigma + g_lRightMotorPulseSigma ) / 2;//左轮和右轮的速度平均值等于小车速度 g_lLeftMotorPulseSigma = g_lRightMotorPulseSigma = 0; //全局变量，注意及时清零 g_fCarSpeed = 0.7 * g_fCarSpeedPrev + 0.3 * g_fCarSpeed ;//低通滤波，使速度更平滑 g_fCarSpeedPrev = g_fCarSpeed; //保存前一次速度 fDelta = CAR_SPEED_SET - g_fCarSpeed;//误差=目标速度-实际速度 g_fCarPosition += fDelta;//对速度误差进行积分 //设置积分上限设限 if((int)g_fCarPosition > CAR_POSITION_MAX) g_fCarPosition = CAR_POSITION_MAX; if((int)g_fCarPosition g_fSpeedControlOutNew 为最新一次速度环控制的 PID 输出， g_fSpeedControlOutOld 为上一次速度环 PID 控制输出值，fValue 为两者之间差值，求出此次 PID 输出值较上一次变化了多少，然后按比例将变化的 fValue 值逐渐加到上一次 PID 输出值，从而得到最新的当前 PID 输出值。这里面的参数设置尤为重要，我要分多少份加，多长时间加完等等。首先来看多长时间内加完，这取决于控制周期，一定要小于等于控制周期才可以。比如说我当前的速度环控制周期为 25ms，那么我就要必须在 25ms 内将之前的 PID 输出值加到最新的 PID 输出值，所以我这里将 fvalue 值分成 25 份，每 1ms 执行一次平滑函数，每执行一次平滑函数都在之前的基础上增加 4%，这样 fvalue 值全部加完刚好是 100ms，当然要想形成每 ms 增加 4%，g_nSpeedControlPeriod 这个参数也要在 1ms 中断中不断++，直到 25ms 时间到执行速度环控制函数时将其清零。平滑地逐步逼近输出最后的计算值 这段代码的意思：速度外环平滑输出函数，速度的 PWM 改变量如果在 25ms 时刻计算出后立刻输出，会造成不平滑抖动等，这段代码本意就是把这个 25ms 周期计算一次得到的 PWM 分配到 25 个 1ms 时间去输出，平滑地逐步逼近输出最后的计算值！但是又因为 MotorOutput() 是 5ms 才运行一次，平滑输出函数的实际效果变成了将 25ms周期计算到的 PWM 分配到 5 个 5ms 时间去输出，平滑地逐步逼近输出最后的计算值！ 对电机输出函数进行改造： void MotorOutput(void)//电机输出函数,将直立控制、速度控制、方向控制的输出量进行叠加,并加入死区常量，对输出饱和作出处理。 { g_fLeftMotorOut = g_fAngleControlOut - g_fSpeedControlOut;//这里的电机输出等于角度环控制量 + 速度环外环,这里的 - g_fSpeedControlOut 是因为速度环的极性跟角度环不一样，角度环是负反馈，速度环是正反馈 g_fRightMotorOut = g_fAngleControlOut - g_fSpeedControlOut; /*增加电机死区常数*/ if((int)g_fLeftMotorOut>0) g_fLeftMotorOut += MOTOR_OUT_DEAD_VAL; else if((int)g_fLeftMotorOut0) g_fRightMotorOut += MOTOR_OUT_DEAD_VAL; else if((int)g_fRightMotorOut MOTOR_OUT_MAX) g_fLeftMotorOut = MOTOR_OUT_MAX; if((int)g_fLeftMotorOut MOTOR_OUT_MAX) g_fRightMotorOut = MOTOR_OUT_MAX; if((int)g_fRightMotorOut 并且在 control.h 头文件中，进行声明。 extern int g_nSpeedControlPeriod;//速度环控制周期计算量 void SpeedControlOutput(void); 回到 stm32f1xx_it.c 文件中，找到滴答中断服务函数 SysTick_Handler()，进行修改。 void SysTick_Handler(void) { /* USER CODE BEGIN SysTick_IRQn 0 */ g_nMainEventCount++;//每进一次中断，主事件函数自动加1 g_nSpeedControlPeriod++;//速度环控制周期计算量自动加1 SpeedControlOutput(); //速度环控制平滑输出处理，速度的pwm改变量如果在25ms时刻计算出后立刻输出，会造成不平滑抖动等，这段代码就是把这个25ms周期计算一次得到的pwm分配到5个5ms时间去输出，平滑地逐步逼近输出最后的计算值！ if(g_nMainEventCount>=5)//SysTick是1ms一次，这里判断语句大于5就是5ms运行一次 { g_nMainEventCount=0;//主事件循环每5ms循环一次，这里清零，重新计时。 GetMotorPulse(); }else if(g_nMainEventCount==1){//这1ms时间片段获取数据和角度计算 GetMpuData();//获取MPU-6050数据 AngleCalculate(); //进行角度计算 }else if(g_nMainEventCount==2){ AngleControl(); //这1ms时间片段进行角度控制 }else if(g_nMainEventCount==3){ g_nSpeedControlCount++; if(g_nSpeedControlCount >= 5) { SpeedControl(); //速度控制，25ms进行一次 g_nSpeedControlCount=0; //清零 g_nSpeedControlPeriod=0;//清零 } }else if(g_nMainEventCount==4){ MotorOutput(); //电机输出函数，每5ms执行一次 } ButtonScan(); /* USER CODE END SysTick_IRQn 0 */ HAL_IncTick(); /* USER CODE BEGIN SysTick_IRQn 1 */ /* USER CODE END SysTick_IRQn 1 */ } 此时，速度环控制平滑输出函数也编写好了。接着，按照上一个章节调试 PID 的步骤，重新对角度环、速度环的 PID 参数进行整定，这里不再重复说明。经过我们的调试，得到角度环 fP=65.0;fD=2.3 ，速度环 fP=10.25,fI=0.108时，可以取得良好的效果。当然，这不是最优值，萌新们可以在这个范围上下调试，以获得更好的控制效果。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"E11.html":{"url":"E11.html","title":"移植U8g2单色图形库驱动OLED","keywords":"","body":"移植u8g2单色图形库驱动OLED 本小节教你将 u8g2 单色图形库移植到 STM32 单片机上，用于驱动 0.96 OLED 液晶屏显示模块。 大型的 GUI 解决方案并不适合像 0.96 OLED（128x64 像素，基于 SSD1306）这种资源紧缺型的显示模组使用，而网络上随处可见的代码资源都只是简单地实现一个字符输出功能，达不到预期的目的。幸好，在一个月黑风高的晚上，我在查阅资料中无意中发现了 u8g2，通过学习后发现该显示库支持很多种字体 fonts（英文和数字），而且具有完整的驱动函数库（直线、圆形、斜线、字符旋转镜像反白、bitmap 一应俱全）和丰富的演示 Demo，特别适合应用在嵌入式 MCU 上面。于是，我把它移植到了 STM32 上面，并写下了本章节作为记录。 u8g2是什么 u8g2 是目前在 Arduino 平台上使用最广泛的单色屏驱动库，在 Github 上超过 1.3K Star，1800 Commit。 u8g2的优势 为什么要使用 u8g2 库？也就是说，u8g2 库能带给我们的开发带来什么便利： u8g2 库支持市面上的大部分 OLED 液晶屏显示模块； u8g2 库功能非常丰富，而且编写有完整的驱动函数库，直接调用即可。 u8g2 库移植简单，容易使用。 0.96 OLED Image 5.19.1 - 0.96 OLED 我们使用的 0.96 OLED 是由 SSD1306 OLED 驱动芯片进行驱动点亮，使用 SPI 接口进行通信。 0.96 OLED 与 STM32 的引脚连接原理图： Image 5.19.2 - 引脚连接原理图 0.96 OLED 引脚 功能描述 对应 STM32 引脚 GND 电源地 GND VCC 3.3V 3.3V SCL CLK时钟 PB15 SDA MOSI数据 PB14 RST 复位 PB13 D/C 数据/命令 PC13 需要注意的是，STM32 跟 0.96 OLED 的通信是只需要 STM32 发送指令和数据到 OLED，OLED 并不需要反馈任何数据给 STM32。因此，你可以看到 OLED 模块是只有 MOSI（SDA）引脚，没有 MISO 引脚的。 坐标系 OLED 其实就是一个 M * N 的像素点阵，想显示什么就得把具体位置的像素点亮起来。 坐标系如下图所示，左上角是原点，向右是 X 轴，向下是 Y 轴。 0.96 OLED 的坐标系要牢记清楚。 移植步骤 这里没有使用 STM32 的硬件 SPI 接口，而是使用 GPIO 口 模拟 SPI 进行通信。 进入我们上一小节实验的 MiaowLabs-Demo 文件夹，找到 MiaowLabs-Demo.ioc 工程文件，双击，打开工程。 Image 5.19.3 - 配置相关引脚 配置完毕，点击生成代码按钮，重新生成代码。 相关链接：u8g2 先从上面相关链接，打开 Github，下载 u8g2 的代码压缩包。你可以把压缩包保持到桌面。 Image 5.19.4 - 下载u8g2代码 对压缩包解压，可以看到 u8g2-master 文件夹里有好多文件和文件夹。 Image 5.19.5 - 解压 我们在移植过程总主要用的是 csrc 文件夹里面的文件，其他文件夹和文件可以等有空再去探究。 在 csrc 文件夹里，点击按类型排序，可以看到有两个 .h 头文件（u8g2.h 和 u8x8.h），其他的都是 .c 源文件。其中，u8x8_d_xxx.c 之类的文件是对应屏幕驱动的文件，我们在这里使用 u8x8_d_ssd1306_128x64_noname.c。 复制 csrc 文件夹里面的两个 .h 头文件到小车项目工程里的 Inc 文件夹，复制其他的所有文件到 Src 文件夹（注意， u8x8_d_xxx.c 这类文件只保留 u8x8_d_ssd1306_128x64_noname.c）。 其中 u8x8_d_ssd1306_128x64_noname.c 是随 oled 屏的驱动芯片来选择的（这里 OLED 的驱动芯片是 ssd1306 ） Image 5.19.6 - 复制头文件到Inc文件夹中 Image 5.19.7 - 复制源文件到Src文件夹中 使用 MDK-ARM 打开工程，把复制到 Src 文件夹中的源文件都加入到工程的 Application/User 文件夹中去。 Image 5.19.8 - 把相关文件全部加入到MDK-ARM工程中 在 main.c 中添加两个 .h 头文件： Image 5.19.9 - 在main.c中添加h头文件 新建一个文件，保存到 Inc 文件夹，命名为 oled.h，敲入以下代码： #ifndef __OLED_H_ #define __OLED_H_ #include \"u8g2.h\" #include \"u8x8.h\" void OLED_Init(void); uint8_t u8x8_stm32_gpio_and_delay(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr); #endif 新建一个文件，保存到 Src 文件夹，命名为 oled.c。 然后在再加入以下代码，即创建一个回调函数（可根据相关的宏来知其意，比如U8X8_MSG_GPIO_SPI_DATA就是表示软件模拟spi的数据管脚，那个arg_int表示是将当前管脚置高还是复位，其中的OLED_Init()是OLED初始化函数）： #include \"gpio.h\" #include \"oled.h\" #define OLED_RST_Clr() HAL_GPIO_WritePin(GPIOB,OLED_RST_Pin,GPIO_PIN_RESET) #define OLED_RST_Set() HAL_GPIO_WritePin(GPIOB,OLED_RST_Pin,GPIO_PIN_SET) #define OLED_DC_Clr() HAL_GPIO_WritePin(GPIOC,OLED_DC_Pin,GPIO_PIN_RESET) #define OLED_DC_Set() HAL_GPIO_WritePin(GPIOC,OLED_DC_Pin,GPIO_PIN_SET) #define OLED_SCLK_Clr() HAL_GPIO_WritePin(GPIOB,OLED_SCL_Pin,GPIO_PIN_RESET) #define OLED_SCLK_Set() HAL_GPIO_WritePin(GPIOB,OLED_SCL_Pin,GPIO_PIN_SET) #define OLED_SDIN_Clr() HAL_GPIO_WritePin(GPIOB,OLED_SDA_Pin,GPIO_PIN_RESET) #define OLED_SDIN_Set() HAL_GPIO_WritePin(GPIOB,OLED_SDA_Pin,GPIO_PIN_SET) void OLED_Init(void) { GPIO_InitTypeDef GPIO_InitStruct = {0}; /* GPIOB/GPIOC clock enable */ __HAL_RCC_GPIOB_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE(); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(OLED_DC_GPIO_Port, OLED_DC_Pin, GPIO_PIN_RESET); /*Configure GPIO pin Output Level */ HAL_GPIO_WritePin(GPIOB, LED_Pin|OLED_RST_Pin|OLED_SDA_Pin|OLED_SCL_Pin, GPIO_PIN_RESET); /*Configure GPIO pin : PtPin */ GPIO_InitStruct.Pin = OLED_DC_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(OLED_DC_GPIO_Port, &GPIO_InitStruct); /*Configure GPIO pins : PBPin PBPin PBPin PBPin PBPin */ GPIO_InitStruct.Pin = OLED_RST_Pin|OLED_SDA_Pin|OLED_SCL_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); } uint8_t u8x8_stm32_gpio_and_delay(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr) { switch (msg) { case U8X8_MSG_GPIO_AND_DELAY_INIT: OLED_Init(); break; case U8X8_MSG_GPIO_SPI_DATA: if(arg_int)OLED_SDIN_Set(); else OLED_SDIN_Clr(); break; case U8X8_MSG_GPIO_SPI_CLOCK: if(arg_int)OLED_SCLK_Set(); else OLED_SCLK_Clr(); break; case U8X8_MSG_GPIO_CS: //CS默认接地 case U8X8_MSG_GPIO_DC: if(arg_int)OLED_DC_Set(); else OLED_DC_Clr(); break; case U8X8_MSG_GPIO_RESET: if(arg_int)OLED_RST_Set(); else OLED_RST_Clr(); break; //Function which delays 100ns case U8X8_MSG_DELAY_100NANO: __NOP(); break; case U8X8_MSG_DELAY_MILLI: HAL_Delay(arg_int); break; default: return 0;//A message was received which is not implemented, return 0 to indicate an error } return 1; } 裁剪 u8g2_d_setup.c u8g2_d_memory.c 文件中与 ssd1306 无关的代码，减小代码体积，ram用量。 u8g2_d_setup.c 只保留 u8g2_Setup_ssd1306_128x64_noname_f 函数，其他全部删掉。 Image 5.19.10 - 裁剪u8g2_d_setup.c u8g2_d_memory.c 只保留 *u8g2_m_16_8_f 函数，其他全部删掉。 Image 5.19.11 - 裁剪u8g2_d_memory.c 在 main.h 头文件加入 oled.h 头文件。 Image 5.19.12 - 加入oled.h头文件 在主函数中初始化 u8g2，先创建 u8g2 的句柄，并创建一个临时变量 nTemp： Image 5.19.13 - 创建 u8g2 句柄 修改 main() 函数，初始化 u8g2 显示库，增加显示代码。 u8g2_Setup_ssd1306_128x64_noname_f(&u8g2,u8g2_R0,u8x8_byte_4wire_sw_spi,u8x8_stm32_gpio_and_delay);//初始化u8g2 u8g2_InitDisplay(&u8g2);//初始zai化显示器 u8g2_SetPowerSave(&u8g2,0);//唤醒显示器 Image 5.19.14 - 初始化u8g2 在主循环中添加以下代码： u8g2_ClearBuffer(&u8g2);//清空缓冲区的内容 if(++nTemp>=32) nTemp=1; u8g2_DrawCircle(&u8g2,64,32,nTemp,u8g2_DRAW_ALL);//画圆 u8g2_DrawCircle(&u8g2,32,32,nTemp,u8g2_DRAW_ALL);//画圆 u8g2_DrawCircle(&u8g2,96,32,nTemp,u8g2_DRAW_ALL);//画圆 u8g2_SendBuffer(&u8g2);//绘制缓冲区的内容 Image 5.19.15 - 修改主循环代码 重新编译，下载，可以看到三个循环变化圆环不断地变化。 Image 5.19.16 - OLED显示三个圆环 如果我们想显示数据，比如显示小车的实时角度，那该怎么办呢？ 其实也并不困难。我们先在初始化部分对字体设置函数 u8g2_SetFont 进行初始化。 u8g2_Setup_ssd1306_128x64_noname_f(&u8g2,u8g2_R0,u8x8_byte_4wire_sw_spi,u8x8_stm32_gpio_and_delay);//初始化u8g2 u8g2_InitDisplay(&u8g2);//初始zai化显示器 u8g2_SetPowerSave(&u8g2,0);//唤醒显示器 u8g2_SetFont(&u8g2,u8g2_font_6x12_mr);//设置英文字体 然后，声明一个数组 char cStr[3];。 /* USER CODE BEGIN 1 */ u8g2_t u8g2; char cStr[3]; /* USER CODE END 1 */ 再写好功能部分代码。 u8g2_ClearBuffer(&u8g2);//清空缓冲区的内容 u8g2_DrawStr(&u8g2,0,30,\"Angle:\");//输出固定不变的字符串Angle： sprintf(cStr,\"%5.1f\",g_fCarAngle);//将角度数据格式化输出到字符串 u8g2_DrawStr(&u8g2,50,30,cStr);//输出实时变化的角度数据 u8g2_SendBuffer(&u8g2);//绘制缓冲区的内容 值得注意的是，我们要先使用标准库函数 sprintf() 对角度数据（原来的格式为浮点型）格式化输出为字符串，再使用函数 u8g2_DrawStr() 显示到 OLED 显示器上。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A41.html":{"url":"A41.html","title":"驱动超声波传感器","keywords":"","body":"驱动超声波传感器 HC-SR04 是一款常见的用于单片机应用的超声波测距模块。超声波发射器向某一方向发射超声波，在发射的同时开始计时，超声波在空气中传播，途中碰到障碍物就立即返回来，超声波接收器收到反射波就立即停止计时。声波在空气中的传播速度为 340m/s，根据计时器记录的时间 t，就可以计算出发射点距障碍物的距离 s，即：s=340m/s∗t/2 s=340m/s*t/2 s=340m/s∗t/2。这就是时间差测距法。HC-SR04 超声波测距模块测量距离：2cm~450cm（理论值）。 工作原理 采用 IO 口 TRIG 触发测距，给至少 10us 的高电平信号; 模块自动发送 8 个 40KHz 的方波，自动检测是否有信号返回； 有信号返回，通过 IO 口 ECHO 输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间。测试距离=(高电平时间*声速)/2; （注：超声波在空气中速度为 340m/s） 看文字不是很直观，看超声波时序图最直接最简单粗暴，如下图所示。 Image 5.20.1 - 超声波时序图 alt > 以上时序图表明，你只需要提供一个 10us 以上脉冲触发信号，该模块内部将发出 8 个 40KHz 周期电平并检测回波。一旦检测到有回波信号输出回响信号。回响信号脉冲宽度与所测的距离成正比。由此通过发射信号到收到的回响信号时间间隔可以计算得到距离。公式：us/58=厘米 或者 us/148=英寸；或者 距离=高电平时间*声速（340M/S）/2。建议测量周期为 60ms 以上，以防止发射信号对回响信号的影响。 使用思路 初始化时，将 TRIG 和 ECHO 端口都置低，首先向给 TRIG 发送至少10us 的高电平脉冲（模块自动向外发送 8 个 40KHz 的方波），然后等待，捕捉 ECHO 端输出上升沿，捕捉到上升沿的同时，打开定时器开始计时，再次等待捕捉 ECHO 的下降沿，当捕捉到下降沿，读出计时器的时间，这就是超声波在空气中运行的时间，按照公式：测试距离=(高电平时间*声速)/2，就可以算出超声波到障碍物的距离。 注意事项 此模块不宜带电连接。如果要带电连接，则先让模块的 GND 端先连接，否则会影响 模块工作。 测距时，被测物体的面积不少于 0.5 平方米且要尽量平整，否则会影响测试结果。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"A45.html":{"url":"A45.html","title":"驱动红外循迹模块","keywords":"","body":"红外循迹模块 产品参数 工作电压：+5V 工作电流：220mA±10mA； 工作温度：-10°~ +50° 安装孔径：M3 检测距离：0.2mm 至 30mm 可调（距离越远，精度越差，越容易误判） 调节方法：按板子上的箭头方向调节可调电阻，检查距离变远，精度变差。默认可调电阻位置适中。 模块接口：XH2.54-4P 接口（La、Lb、Ra、Rb 四路信号输出，Vcc 为电源正，Gnd 为电源地） 输出信号：TTL 电平（可直接连接单片机 GPIO 引脚，传感器检测到反射回来的红外光时，相应的引脚输出低电平，否则输出高电平） 接线说明 名称 说明 Vcc 电源正 Gnd 电源地 La 左 a 路红外 TTL 电平输出 Lb 左 b 路红外 TTL 电平输出 Ra 右 a 路红外 TTL 电平输出 Rb 右 b 路红外 TTL 电平输出 Image 5.21.1 - 红外模块示意图 alt > 工作原理 黑线的检测原理是红外发射管发射光线到路面，红外光遇到白底则被反射，接收管接收到反射光内，经施密特触发器整形后输出低电平；当红外光遇到黑线时则被吸收，接收管没有接收到反射光，经施密特触发器整形容后输出高电平。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"F04.html":{"url":"F04.html","title":"网友改造投稿","keywords":"","body":"网友改造投稿 本章展示部分基于「小霸王Lite」两轮自平衡小车二次开发的视频。欢迎广大网友投稿。投稿邮箱：121349840@qq.com（来稿请注明投稿） 「小霸王Lite」+ 舵机云台超声波避障 （点击文字可转跳到视频网站） 忘记是哪个网友发过来的了，看到请联系哦。 「小霸王Lite」+ PS2手柄遥控 + 灭火功能 （点击文字可转跳到视频网站） 来自网友 @零零 的改造和投稿。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}