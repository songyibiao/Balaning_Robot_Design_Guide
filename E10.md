# 调整机械零点偏移值

到这里，速度环也调好了，小车在设计的时候就把重心放到了车轮同轴的位置，所以前面我们一直都不用调整机械零点，因为默认情况下机械零点为零。但是有时候小车还需要添加其他的硬件模块，比如在车前挂载红外模块以获得循迹功能，如果模块比较重，平衡小车的重心就会发生明显的偏移，导致小车无法在原地平衡，会缓慢朝一侧运动。要解决这个问题，就需要重新调整机械零点偏移值，也就是通过软件调节小车的倾斜角度，把小车的重心位置重新调整到车轴同轴的位置。因为没有调好角度环和速度环，很难看出机械零点的作用和意义，我们在这里适当加上机械零点偏移值。

我们打开 control.c 文件，加上机械零点偏移值的宏定义。

```c
#define CAR_ZERO_ANGLE  (g_fCarAngleOffset)  //机械零点偏移值
float g_fCarAngleOffset= 0;//每辆小车的机械零点都不一定相同
```

我们先用一个宏定义 CAR_ZERO_ANGLE 封装变量 g_fCarAngleOffset，然后 g_fCarAngleOffset 初始化时赋值为 0。

然后，在 control.h 头文件中声明这个变量，以便我们调用。

```
extern float g_fCarAngleOffset;
```

我们小车的机械零点偏移值默认为 0。如果加载了其他的硬件模块导致重心偏移严重，可以适当再调节偏移值。偏移值的过小或过大都有可能导致小车最终缓慢往一边运动，无法在原地平衡。每台小车的机械零点都不完全一样，我们也可以从 0 开始往两边尝试，看看哪个机械零点偏移值更适合。如果小车是往前走（超声波模块方向为前，OLED 方向为后），则可以赋值为正，比如 2；如果小车往后走，可以赋值为负，比如 -2。

找到角度计算函数 AngleCalculate(void) ，在里面减去机械零点偏移值的代码。

```c
	//-------加速度数据处理--------------------------
	//量程为±2g时，灵敏度：16384 LSB/g
    x_fAcc = x_nAcc / 16384.0;
    y_fAcc = y_nAcc / 16384.0;
    z_fAcc = z_nAcc / 16384.0;

    g_fAccAngle = atan2(y_fAcc,z_fAcc) * 180.0 / 3.14;

    //-------陀螺仪数据处理-------------------------
    //范围为2000deg/s时，换算关系：16.4 LSB/(deg/s)
	  g_fGyroAngleSpeed = x_nGyro / 16.4;//计算角速度值  			
	
	//-------互补滤波---------------
	g_fCarAngle = ComplementaryFilter(g_fAccAngle, g_fGyroAngleSpeed, dt);
	
	g_fCarAngle = g_fCarAngle - CAR_ZERO_ANGLE;//减去机械零点偏移值
}
```

我们这里就把机械零点偏移值变量加入了代码，后面在加上红外模块等硬件模块时，可以通过调节机械零点偏移值来调整重心，以达到开机即稳的状态。

